[{"title":"obsidian + picgo 图片上传","url":"/2024/03/16/%E6%B5%8B%E8%AF%95%E5%8C%BA/2024-03-16_picgo%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/","content":" obsidian + picgo 图片上传\n 教程\n 1.安装 picgo 软件\nPicGo\n 2.配置picgo软件\n图床使用SMMS\nhttps://smms.app/\n 3.安装 obsidian-image-auto-upload-plugin 插件\nobsidian-image-auto-upload-plugin/readme-zh.md at master · renmu123/obsidian-image-auto-upload-plugin · GitHub\n 测试图片效果\n![]-(附件/2024-03-16_picgo图片上传/image-20240316100436702.png)\n[1]\n","categories":["测试区"],"tags":[]},{"title":"格式化编辑插件","url":"/2024/03/16/%E6%B5%8B%E8%AF%95%E5%8C%BA/2024-03-16_%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%BC%96%E8%BE%91%E6%8F%92%E4%BB%B6/","content":" Editing Toolbar 插件\n\n显示一个标题栏在 obsidian 中，可以进行富文本操作\n\n 演示文案\nobsidian介绍\nObsidian是一款强大的笔记和知识管理软件，它以其独特的特性和灵活的使用方式赢得了广大用户的喜爱。【1】\nObsidian的核心在于其强大的链接功能，用户可以轻松创建和管理笔记之间的关联，形成一张庞大的知识网络。这种网状的知识结构不仅便于用户快速找到所需信息，还能促进思维的发散和深化。\n此外，Obsidian还支持Markdown语法，使得用户可以方便地编辑和格式化笔记内容。同时，它还提供了丰富的插件和主题选择，用户可以根据自己的喜好和需求进行个性化定制。\nObsidian的界面简洁明了，操作便捷，无论是对于学习、工作还是研究，都能提供极大的帮助。它让知识管理变得更加高效和有趣，是一款值得一试的软件。\n总的来说，Obsidian是一款功能强大、易于使用的笔记和知识管理软件，它能够帮助用户更好地组织和管理自己的知识和信息，提升学习和工作效率。\n【1】文心一言3.5生成结果\n","categories":["测试区"],"tags":[]},{"title":"3D建模笔记","url":"/2024/02/03/%E6%96%87%E6%A1%A3%E5%8C%BA/2024/2024-02-03_3D%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/","content":" 3D建模笔记\nsolidworks\n\n 绘制螺栓、螺母\n 螺母\n 绘制孔\n\n使用异型孔向导\n旋转“孔类型”为“孔”\n标准为GB（国标）\n类型为“螺钉间隙”\n孔规格大小设置为“自己想要的大小“，包含三个尺寸（紧密、正常、松弛）\n其他根据情况调节\n\n 绘制螺纹\n\n异型孔向导下拉菜单选择”螺纹线“\n类型选择”MericDie“\n螺纹线方法选择”拉伸螺纹线“\n镜像轮廓–垂直镜像\n螺纹选项–根据开始面修剪–根据结束面修剪\n\n 螺栓\n 绘制螺柱\n\n异型孔向导下拉菜单选择”螺柱向导“\n标准选择”GB“\n类型选择”机械螺纹“\n大小选择自己想要的\n\n 绘制螺纹\n\n异型孔向导下拉菜单选择”螺纹线“\n类型选择”MericDie“\n螺纹线方法选择”剪切螺纹线“\n螺纹选项–根据开始面修剪–根据结束面修剪\n\n 旋转建模\n\n先画一根中心线，然后沿着中心线画想要的形状\n点击中心线，接着在在特征中旋转凸台\n\n 打孔误差\n1.放置磁铁时，将孔增大0.4mm\n","categories":["文档区"],"tags":["3D建模","3D打印"]},{"title":"3D打印笔记","url":"/2024/02/03/%E6%96%87%E6%A1%A3%E5%8C%BA/2024/2024-02-03_3D%E6%89%93%E5%8D%B0%E7%AC%94%E8%AE%B0/","content":" 3D打印学习笔记\n\n最后更新：2024-03-24\n\n最近买了一台3D打印机学习一下怎么用。尝试打印了几个模型后，感觉机器还是可以，就是下次换成高速打印机。\n 常见问题处理\n 打印模型翘边：\n\n增加裙边\n增加圆盘固定\n喷涂固定胶水到打印平面\n\n 支撑：\n\n不采用全部支撑，因该换成树形状支撑或其他支撑类型\n\n 打 印时堆料严重：\n\n开启Z轴回抽\n提高一点点Z轴\n\n Z缝明显：\n\n可以将Z缝设置到拐角或模型内部\n\n 表层空隙：\n\n启动熨平功能\n\n 夹角空隙：\n\n不要开启“滤除微小的间隙”\n【3D打印教程】CURA”填满顶部表层空隙”的6个相关参数(切片软件参数设定进阶教学)_哔哩哔哩_bilibili\n\n 放置磁铁：\n&gt;在特定层自动暂停教程 | ELEGOO Wiki\n 支撑拦截器：\n可以设置自定义区域不生成支撑，这样打印螺丝孔就不会堵住。\n\n 起始层\n打印时起始层（与打印平台接触的那一层），不好看，线之间有缝隙。\n1.在”材料“选项中调整”起始层“流量（太多线容易拱起，太少线之间缝隙就越大）\n![]-(附件/2024-02-03_3D打印笔记/image-20240324144648370.png)\n\n 优化\n\n打印不需要不受力的零件时，不需要设置为100%填充\n熨平功能可以增加表面平整度\n使用树形支撑记得设置填充比例，要不然浪费材料\n\n","categories":["文档区"],"tags":["3D打印"]},{"title":"《克拉拉与太阳》","url":"/2023/12/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2023-12-16_%E5%85%8B%E6%8B%89%E6%8B%89%E4%B8%8E%E5%A4%AA%E9%98%B3/","content":" 《克拉拉与太阳》\n了解事情的全貌，才做判断-----\n读到克拉拉帮乔西送信到时候，根据前面里克出场的行为，我还以为里克是一个幼稚的小孩，控制欲很强，老是担心这担心那的。直到送信结束才发现是我自己误会了，果然正如里克所说的“一面之词”\n读到他们想要“克拉拉”代替乔西，在乔西离去之后。全身鸡皮疙瘩都起来了。灵魂与躯壳的替换，究竟可行吗？正如乔西老爸说的，乔西真的是独一无二的吗？\n…\n12月16号日读完，这本书读起来平平淡淡，一些叙事感觉很跳跃，但读到最后还是可以，最后躺在废墟垃圾场的克拉拉还是那么单纯。因为她对人类的好都是提前设定的，怎么能看出她真正的心是什么样的，但是正是这单纯的心与复杂的人心截然不同。\n送给自己的一句话 “读书的过程不要总是想要获取到什么，要多思考，慢慢的随着阅读量的增加，自己也才能够得到进步”\n","categories":["读书笔记"],"tags":["读书笔记"]},{"title":"《平面国》","url":"/2023/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2023-11-28_%E5%B9%B3%E9%9D%A2%E5%9B%BD/","content":" 平面国-读书笔记\n 感想\n这本书阅读的时间跨度很大，大概有几个学期了。买kindle的时候开始看的，每次都是在回家或去学校的火车上阅读的。2023-11-28 终于看完啦。\n读完该书我的感想很多，开拓思维去想象二维的一个世界，里面的人长什么样子，世界运行的规则又是什么。\n不要固步自封，”向上，而不是向北“。在成为直线国王、正方形或球形使者时要虚心听取意见。\n带着现有的知识与思维去与别人讨论问题时，不要认为我已经了解东西，别人就也应该知道。不要认为自己比其他人多一点知识就高高自傲。\n 摘抄\n网络真的让我们接触更多信息、鼓励我们思考了吗？还是恰恰相反，科技允许我们制作出巨大的泡泡，每天生活于其中，只与和自己观点相近的人交流？若是后者，这种所谓的“交流”与点国国王的自言自语有何不同？\n\n","categories":["文档区"],"tags":[]},{"title":"锂电池电源切换芯片选择错误","url":"/2023/10/31/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/2023-10-31_%E8%8A%AF%E7%89%87%E9%80%89%E6%8B%A9%E9%94%99%E8%AF%AF/","content":" 锂电池电源切换芯片选择错误\n 故障图片\n\n\n 故障描述\n前段时间设计了一个锂电池充放电的切换电路，外部5V供电时锂电池正常充电不放电，外部5V直接供电，移除外部5V时锂电池输出并升压到5V，达到UPS的效果。\n经过测试整个电路完全可以正常工作，瞬间切换的效果很好。但是我接上了一个小电机时，刚开始还可以正常旋转，但一段时间后PCB上的元器件直接烧起来了。后来检测一次一次检测发现是PW5100这个升压芯片的问题，它的最大工作电流只有1500mA，特别的当作为负载的电机被强制减速时，负载电流瞬间增加。PCB上的PW5100直接就烧了。\n 错误总结\n选择芯片必须考虑最坏工作情况，给电压电流留升降空间。\n","categories":["踩坑记录"],"tags":["故障"]},{"title":"单片机引脚驱动电路","url":"/2023/10/16/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-10-16_%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%95%E8%84%9A%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF/","content":" 单片机引脚驱动电路(三极管)\n\n在使用单片机控制其他模块时，难免会碰到单片机供电足的问题。\n例如：不可能直接用单片机电源驱动蜂鸣器、继电器等等模块。所以模块需要单独供电，而单片机只输出控制信号即可\n\n 元器件清单\n三极管：S8050 （NPN型）\n二极管：1N4007W\n 三极管工作原理\n三极管的工作原理详解，图文+案例，立马教你搞懂 - 知乎 (zhihu.com)\n 接线图\n\n以蜂鸣器和继电器控制为例\n\n三极管的发射极接地\n三极管的基极接控制信号\n三极管的集电极连接二极管的正极\n二极管负极接高电平\n用电器的正负极接二极管的两端\n\n\n","categories":["文档区"],"tags":["电路","驱动电路"]},{"title":"基于ESP32的物联网开发板","url":"/2023/10/01/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2023-10-01_%E5%9F%BA%E4%BA%8EESP32%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91%E6%9D%BF/","content":" 基于ESP32的物联网开发板\n 主控\nESP32-WROOM-32D\n包含WiFi和蓝牙\n 模块功能\n\noled屏幕\n12V继电器\n24V电机驱动\n12V双电机驱动\nDS1302时钟\n蜂鸣器\n2个三线传感器接口\n1个四线传感器接口\n\n 3D图\n\n 实物图\n\n","categories":["实践项目"],"tags":["PCB","芯片","电路","开发板","ESP32"]},{"title":"ESP32开发板","url":"/2023/09/07/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2023-09-07_ESP32%E5%BC%80%E5%8F%91%E6%9D%BF/","content":" ESP32开发板\n 芯片说明\n ESP32-WROOM-32D\n 原理图\n\nESP32开发板 - 嘉立创EDA开源硬件平台 (oshwhub.com)\n\n 参考文章\nESP32选型一文就够，ESP32-WROOM-32、ESP32-WROVER、ESP32-S衍生模组、ESP32-PICO差异 - 哔哩哔哩 (bilibili.com)\nESP32-WROOM-32 | 乐鑫科技 (espressif.com.cn)\nESP32 系列模组和开发板 - ESP32 - — ESP-IDF 编程指南 v4.3.1 文档 (espressif.com)\n","categories":["实践项目"],"tags":["PCB","芯片","电路","开发板","ESP32"]},{"title":"基于L298N芯片的电机驱动","url":"/2023/09/04/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2023-09-04_%E5%9F%BA%E4%BA%8EL298N%E8%8A%AF%E7%89%87%E7%9A%84%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8/","content":" 基于L298N芯片的电机驱动\n\n通过控制IN1~4的引脚电平，实现电机的正转反转以及转速\n\n 芯片说明\n L298N\nL298N 电机驱动板 - 详细介绍 - 知乎 (zhihu.com)\n 原理图\n\n一个L298N模块 - 嘉立创EDA开源硬件平台 (oshwhub.com)\n\n 相关文章\nL298N电机驱动模块的接线使用与代码实现_l298n的ena连接pwm_Clichong的博客-CSDN博客\n","categories":["实践项目"],"tags":["PCB","芯片","电路","驱动电路"]},{"title":"电源切换以及dc-dc电路","url":"/2023/08/29/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2023-08-29_%E7%94%B5%E6%BA%90%E5%88%87%E6%8D%A2%E4%BB%A5%E5%8F%8Adc-dc%E7%94%B5%E8%B7%AF/","content":" 电源切换以及dc-dc电路\n\n这个主要是在上次TP4056充放电路基础上再加上了dc-dc电路和电源切换电路\n\n 2023-09-09更新说明：测试以后发现锂电池充电、放电升压正但是pw5100这个芯片选错了，切换那一瞬间，产生大电流，pw5100直接冒烟了\n 芯片说明\n PW5100\n干电池升压IC，PW5100电路设计注意点_usb type的博客-CSDN博客\n\n型号PW5100\n类型同步整流升压器\n输入电压范围0.7V~ 5V\n输出电压范围3.0V~ 5V\n输出电流600mA\n\n 电源切换电路\nUSB外接电源与锂电池自动切换电路设计_strongerHuang的博客-CSDN博客\n 原理图\n\n图中的一些错误简单修改一下就可以了，整个模块测试是可以用的\n\n 相关文章\n数十个锂电池充放电电路，锂电池充放电芯片_锂电池放电电路_kuakewei123的博客-CSDN博客\n简单实用的双向电平转换电路(非常实用!)3.3V-5V_不太油腻的中年大叔的博客-CSDN博客\n锂电池3V,3.3V.3.7V升压5V，大小电流方案集合！自制3v升5v升压电路_小_马克的博客-CSDN博客\n","categories":["实践项目"],"tags":["PCB","芯片","电路","电源"]},{"title":"MSS22D18G2开关引脚错误","url":"/2023/08/29/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/2023-08-29_MSS22D18G2%E5%BC%80%E5%85%B3%E5%BC%95%E8%84%9A%E9%94%99%E8%AF%AF/","content":" MSS22D18G2开关引脚错误\n用的立创EDA的元件库，没想到真是坑人，原理图引脚和封装引脚是错位的\n啊啊啊啊啊！\n当然这是用户贡献的封装库，怪我没仔细看。\n\n\n","categories":["踩坑记录"],"tags":[]},{"title":"硬件入门之点亮一个电容","url":"/2023/08/29/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-08-29_%E7%A1%AC%E4%BB%B6%E5%85%A5%E9%97%A8%E4%B9%8B%E7%82%B9%E4%BA%AE%E4%B8%80%E4%B8%AA%E7%94%B5%E5%AE%B9/","content":" 点亮一个电容\n插上电源以后，pcb变电熨斗，电容飘出“魔法烟雾”, 然后…\n\n","categories":["文档区"],"tags":["吐槽"]},{"title":"esp32控制舵机旋转问题","url":"/2023/08/28/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/2023-08-28_esp8266%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA%E6%97%8B%E8%BD%AC%E9%97%AE%E9%A2%98/","content":" esp8266控制舵机旋转问题\n 问题\n网上买了个180度的MG90s舵机，买回来用arduino写了代码，发现舵机只能转90库，我以为我买到假的了，于是又在网上买了360舵机，想着360度这下总够了吧，结果买回来写入代码后，360度舵机一直转圈圈。\n 原因\n 180度舵机（可以控制角度，方向，速度）\n原来我那个舵机没坏，是arduino中的Servo.h库的代码没写对,Servo库的默认脉冲时间为544-2400 μs(即 servo.attach(Servo_pin,544,2400))，而实际需要的脉冲为500-2500 μs,因此我们改一下默认的attach()定义就好了。\n错误代码：\nmyservo.attach(14); //D5  \n正确代码：\nmyservo.attach(14,500,2500); //D5  \n 360度舵机（可以控制方向和速度，不能直接控制角度）\n舵机还有模拟和数字之分，之前还不知道。下次买东西之前得先学学\n 相关文章\n舵机分类和控制原理简述（180°模拟电机）SG90 MG996R_mg996r是数字舵机还是模拟舵机_田凫。的博客-CSDN博客\nSTM32 SG90舵机应用_舵机可以控制任意角度吗_IC学习者的博客-CSDN博客\narduino的180度舵机与360度舵机控制_360度舵机控制方法_Gen.save的博客-CSDN博客\nESP8266 D1 mini 只能使MG90/MG995/MG996转动90°的解决方案_esp8226驱动步进电机只能转90度_这个人很懒啥也没写的博客-CSDN博客\n","categories":["踩坑记录"],"tags":[]},{"title":"《成为自己的勇气》","url":"/2023/08/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2023-08-24_%E6%88%90%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8B%87%E6%B0%94/","content":" 《成为自己的勇气》\n\n焦虑的人生都是从不接纳自己开始的，成为自己就是一件了不起的事\n\n 你为什么总是感觉不幸福\n\n知足常乐\n人的欲望是一个无底洞，它的本质就是不断地“扩展”\n对欲望的认知更加清晰化，“想要”和“贪欲”是两码事\n动机只是促使人付出行动的因素之一，还要有对目标的坚持和对障碍的克服\n他们认为只有找到了那个自己想要的东西便能克服目前的问题，然而这是一种为了逃避付出和艰难而产生的幻想\n我们常常“高估”别人的“幸福度”\n\n 过于在意别人的看法是一种什么病\n\n如果你习惯与将自己和别人做对比，就必然会受到伤害\n当一个人不能接纳自己的时候，他的内心是空洞无物的，他无法从自身内部获得支撑，而不得不从外界寻求认同和力量\n别人没那么在乎你，也没那么关心你\n这世上只有一种成功，就是用你喜欢的方式度过一生\n\n\n","categories":["读书笔记"],"tags":["读书笔记"]},{"title":"基于TP4056的单节锂电池充电电路","url":"/2023/08/08/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2023-08-08_TP4056%E5%85%85%E7%94%B5%E7%94%B5%E8%B7%AF/","content":" 使用TP4056的制作的单节锂电池充电电路，个人测试项目\n 芯片说明\n\n锂电池管理芯片tp4056中文资料及应用电路图汇总 - IC应用电路图 - 电子发烧友网 (elecfans.com)\n\nTP4056是一款完整的单节锂离子电池采用恒定电流/恒定电压线性充电器。其底部带有散热片的SOP8封装与较少的外部元件数目使得TP4056成为便携式应用的理想选择。TP4056可以适合USB电源和适配器电源工作。由于采用了内部PMOSFET架构，加上防倒充电路，所以不需要外部隔离二极管。热反馈可对充电电流进行自动调节，以便在大功率操作或高环境温度条件下对芯片温度加以限制。充电电压固定于4.2V，而充电电流可通过一个电阻器进行外部设置。当充电电流在达到最终浮充电压之后降至设定值1/10时，TP4056将自动终止充电循环。\n 引脚\nVCC：电压输入\nGND：接地\nCE：芯片使能输入端。高电平有效\nBAT：电池正极（+）连接端\nTEMP：电池温度检测输入端\nPROG：恒流充电电流设置端\nCHRG：充电状态指示端，输出\nSTDBY：充电完成指示端，输出\n 限流电阻阻值表\n\n锂电池充电IC-TP4056电路设计详解_tp4056充电电路图_董程森的博客-CSDN博客\n\n通过设置R3(下图中)电阻，阻值大小，更改BAT端输出电流大小\n\n 功能需求\n\n通过typec接口对锂电池进行充电\n\n BOM清单\nR1：1K（0805）\nR2：1K（0805）\nR3：1.2K（0805）\nC1：10uF（0805）\nC2：10uF（0805）\nU1：4插脚的6针脚TypeC母口\nU2：TP4056芯片（SOP8）\nLED-G：红色LED（0805）\nLED-R：红色LED（0805）\n 原理图\n\n\n 运行效果\n\n 测试总结\n这个只是一个简单的测试项目，目前发现的缺点：\n\nLED灯过亮，尝试加大R1和R2的电阻\n未连接电池，但已连接电源时，LED-R会有微弱的灯光闪烁\n\n 特别说明\n该项目涉及电源部分，请务必小心，谨防意外事故发生！\n 项目文件\nhttps://oshwhub.com/ukers/tp4056-chong-dian-dian-lu\n","categories":["实践项目"],"tags":["PCB","芯片","电路"]},{"title":"Office文件下载测试","url":"/2023/08/04/%E6%B5%8B%E8%AF%95%E5%8C%BA/2023-08-04_Office%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95/","content":" 将文件保存在source/file/文件夹内上传GitHub并通过链接下载\n 测试下载Word\n 嵌入代码\n&lt;div&gt;&lt;b&gt;test.docx&lt;/b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/files/office/test.docx&quot;&gt;&lt;button name=&quot;1&quot;&gt;下载&lt;/button&gt;&lt;/a&gt;&lt;/div&gt;\n\ntest.docx&nbsp;&nbsp;&nbsp;&nbsp;下载\n\n 测试下载Execl\n 嵌入代码\n&lt;div&gt;&lt;b&gt;test.docx&lt;/b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/files/office/test.xlsx&quot;&gt;&lt;button name=&quot;1&quot;&gt;下载&lt;/button&gt;&lt;/a&gt;&lt;/div&gt;\n\ntest.xlsx&nbsp;&nbsp;&nbsp;&nbsp;下载\n\n 测试下载PPT\n 嵌入代码\n&lt;div&gt;&lt;b&gt;test.pptx&lt;/b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/files/office/test.pptx&quot;&gt;&lt;button name=&quot;1&quot;&gt;下载&lt;/button&gt;&lt;/a&gt;&lt;/div&gt;\n\ntest.pptx&nbsp;&nbsp;&nbsp;&nbsp;下载\n","categories":["测试区"],"tags":[]},{"title":"PDF嵌入测试","url":"/2023/08/04/%E6%B5%8B%E8%AF%95%E5%8C%BA/2023-08-04_PDF/","content":" hexo框架下博客页面嵌入PDF文件预览\n PDF预览\n\n由于文件挂载到GitHub上的可能访问有点慢\n\n\ntest.pdf&nbsp;&nbsp;&nbsp;&nbsp;下载\n\n 方法 1\n 嵌入代码\n&#123;% pdf https://uerlink.cn/files/pdf/test.pdf %&#125;   \n注意：\n\n需要在博客根目录中使用git bash或power shell 安装插件\n\n$ npm install --save hexo-pdf\n\n此方法下这个test.pdf在需要外部路径，不能使用/file/pdf/test.pdf\n\n\n\n\t\n    \n\t\n\n\n\n 方法 2\n 嵌入代码\n&lt;div&gt;&lt;embed src=&quot;/files/pdf/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt;\n\n\n\n 方法 3\n 嵌入代码\n&lt;iframe src=&quot;/files/pdf/test.pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt; This browser does not support PDFs. Please download the PDF to view it: &lt;a href=&quot;/index.pdf&quot;&gt;Download PDF&lt;/a&gt; &lt;/iframe&gt;\n 请您下载预览 Download PDF ","categories":["测试区"],"tags":[]},{"title":"PCB贴片焊接练习","url":"/2023/08/03/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-08-03_PCB%E8%B4%B4%E7%89%87%E7%84%8A%E6%8E%A5%E7%BB%83%E4%B9%A0/","content":" 常用贴片元器件焊接练习技巧记录\n 视频如下：\n\n\n\n【贴片集成IC如何用电烙铁焊接？掌握这些技巧，几分钟从入门到熟练】 https://www.bilibili.com/video/BV1aR4y1X7wN/?share_source=copy_web&amp;vd_source=17fc3f0d3cf17f45237a57cc5ba97e0e\n 0805封装下的贴片电阻，电容\n\n先在焊头挂一点锡，挂不住可以沾点助焊剂\n再焊盘一端点上一点锡，另一端先不管\n镊子夹住元器件，放好位置\n焊头点上一点助焊剂，焊盘上的锡融化，固定好元器件\npcb转180度，焊接另一半，左手拿锡丝，挂到焊头上。焊头再把锡挂到元器件上\n\n 特殊情况\n注意：镊子要夹稳，一点要固定好元器件再焊另一端，不然元器件会沾到焊头上去了\n处理点锡拉尖：焊头沾一点锡膏，再把尖头压下去。\n 多引脚芯片焊接\n\n先摆好芯片，然后固定芯片的对角线引脚\n刷上助焊剂，采用拖焊技巧，对芯片进行焊接\n\n 特殊情况\n注意：芯片焊接时，最长时间不要超过3秒，温度260~350，可轻微的用手指感受一下芯片温度，过烫就让芯片冷却再焊接\n","categories":["文档区"],"tags":["练习"]},{"title":"博客上传命令行测试","url":"/2023/08/02/%E6%B5%8B%E8%AF%95%E5%8C%BA/2023-08-02_%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B5%8B%E8%AF%95/","content":" 批处理BAT命令行\n 复制加上传\n@echo offchcp 65001echo ▬▬▬▬▬▬▬▶ 已切换中文编码echo ▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬【文件夹内容复制】▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬rmdir /s /q &quot;D:\\UerLinkBlog\\source\\&quot;echo ▬▬▬▬▬▬▬▶ 已删除“D:\\UerLinkBlog\\source\\”文件夹mkdir &quot;D:\\UerLinkBlog\\source\\&quot;echo ▬▬▬▬▬▬▬▶ 已新建空的source文件夹xcopy /e &quot;C:\\Users\\UerLink\\OneDrive\\个人管理\\知识库\\我的博客&quot; &quot;D:\\UerLinkBlog\\source\\&quot; echo ▬▬▬▬▬▬▬▶ 已复制obsidian的内容到source文件夹echo ▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬【hexo生成静态html文件并上传GitHub】▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬echo ▬▬▬▬▬▬▬▶ 清除缓存已禁用cd /d  D:\\UerLinkBlogtitle HexoGocd %call hexo clean%echo ▬▬▬▬▬▬▬▶ 博客开始重新生成call hexo gecho ▬▬▬▬▬▬▬▶ 博客开始上传GitHubcall hexo decho ▬▬▬▬▬▬▬▶ 博客预览服务启动call hexo spause\n 仅上传\n@echo offchcp 65001echo &quot;▬▬▬▬▬▬▬▬▬▬▬▬▬▶ 已切换中文编码&quot;echo &quot;▬▬▬▬▬▬▬▬▬▬▬▬▬▶ 清除缓存已禁用！如果博客样式出现问题，请重新开启&quot;cd /d  D:\\UerLinkBlogtitle HexoGocd%call hexo clean%echo &quot;▬▬▬▬▬▬▬▬▬▬▬▬▬▶ 博客开始重新生成:&quot;call hexo gecho &quot;▬▬▬▬▬▬▬▬▬▬▬▬▬▶ 博客开始上传GitHub:&quot;call hexo decho &quot;▬▬▬▬▬▬▬▬▬▬▬▬▬▶ 博客预览服务启动:&quot;call hexo spause\n","categories":["测试区"],"tags":[]},{"title":"博客上传常见问题","url":"/2023/08/02/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/2023-08-02_%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","content":" 解决上传时提示warning: LF will be replaced by CRLF in的方法\n 原因\n不同操作系统行尾结束符不一样：\nUinx/Linux --- \\n(LF); windows --- \\r\\n(CRLF)\n 方法\n在git上配置core.autocrlf属性为false，默认为trun\n git config --get core.autocrlf   //查看命令git config --global core.autocrlf false    //修改命令\n","categories":["踩坑记录"],"tags":["blog"]},{"title":"mod开发笔记","url":"/2023/08/02/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-08-02_mod%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","content":" 星露谷物语mod开发\n 每天早晨打印一条消息的代码\n/// &lt;summary&gt;模组的主要入口点。&lt;/summary&gt;public class ModEntry : Mod&#123;    /**********    ** 公共方法    *********/    /// &lt;summary&gt;模组入口点，加载模组后自动调用&lt;/summary&gt;    /// &lt;param name=&quot;helper&quot;&gt;提供用于编写模组的简化API&lt;/param&gt;    public override void Entry(IModHelper helper)    &#123;        // 事件 += 方法        helper.Events.GameLoop.DayStarted += this.OnDayStarted;    &#125;        /**********    ** 私有方法    *********/    /// &lt;summary&gt;在新的一天开始后调用的方法&lt;/summary&gt;    /// &lt;param name=&quot;sender&quot;&gt;事件对象&lt;/param&gt;    /// &lt;param name=&quot;e&quot;&gt;事件参数&lt;/param&gt;    private void OnDayStarted(object sender, DayStartedEventArgs e)    &#123;       this.Monitor.Log($&quot;新的一天到来了！&#123;Game1.player.Name&#125; 享受你的新一天吧&quot;, LogLevel.Debug);    &#125;&#125;","categories":["文档区"],"tags":["mod","game"]},{"title":"算法练习","url":"/2023/08/02/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-08-02_%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/","content":" 简单算法练习\n 习题5-2\n分式化简。设计算法，将一个给定的真分数化简为最简分数形式，例如将6/8 化简为 3/4，使用C++语言\n 关键代码(辗转相除法)（必背）\ngcd函数导入a，b，判断b是否等于0，如果等于就返回a的值，然后接着执行gcd函数将b填入a，a % b\nint gcd(int a, int b) &#123;    if (b == 0) &#123;        return a;    &#125;    return gcd(b, a % b);&#125;\n 代码\n#include &lt;iostream&gt;using namespace std;int gcd(int a, int b) &#123;    if (b == 0) &#123;        return a;    &#125;    return gcd(b, a % b);&#125;int main() &#123;    int x, y;    cout &lt;&lt; &quot;请输入分子和分母：&quot; &lt;&lt; endl;    cin &gt;&gt; x &gt;&gt; y;    int g = gcd(x, y);    x /= g;    y /= g;    cout &lt;&lt; x &lt;&lt; &quot;/&quot; &lt;&lt; y &lt;&lt; endl;    return 0;&#125;\n 解释\n1. 求出分子和分母的最大公约数（使用辗转相除法）。2. 将分子和分母同时除以最大公约数，得到最简分数形式。\n 习题5-3\n设计算法，判断一个大整数能否被11整除。可以采用以下方法：将该数的十进制表示从右端开始，每两位一组构成一个整数，然后将这些数相加，判断其能否被11整除，例如将562843748 分割成 5，62，84，37，48，然后判断（5+62+84+37+48）能否被11整除\n 关键代码（必背）\nbool divisible(int n) &#123;    int sum = 0;    while (n &gt; 0) &#123;        sum += n % 100;        n /= 100;    &#125;    return (sum % 11 == 0);&#125;\n 代码\n#include &lt;iostream&gt;using namespace std;bool divisible(int n) &#123;    int sum = 0;    while (n &gt; 0) &#123;        sum += n % 100;        n /= 100;    &#125;    return (sum % 11 == 0);&#125;int main()&#123;    int n;    cin&gt;&gt;n;    if(divisible(n)) &#123;        cout&lt;&lt;&quot;可以被11整除&quot;&lt;&lt;endl;    &#125;else&#123;        cout&lt;&lt;&quot;不可以被11整除&quot;&lt;&lt;endl;    &#125;&#125;\n 解释\n1. 初始化sum为0。2. 将大整数n逐步取出最后两位数字，加到sum中，直到n变为0为止。3. 判断sum能否被11整除，如果能，则该大整数能被11整除，否则不能。\n 习题5 - 5题\n设计一个算法，在数组r[n]中删除重复的元素，要求移动元素的次数较少，并使剩余元素间的相对次序保持不变\n 代码\n#include &lt;iostream&gt;using namespace std;void removeDuplicates(int r[], int n) &#123;    int i, j, k;    for (i = 0; i &lt; n; i++) &#123;        for (j = i + 1; j &lt; n;) &#123;            if (r[j] == r[i]) &#123;                for (k = j; k &lt; n - 1; k++) &#123;                    r[k] = r[k + 1];                &#125;                n--;            &#125; else &#123;                j++;            &#125;        &#125;    &#125;&#125;int main() &#123;    int r[] = &#123;1, 2, 3, 2, 4, 5, 3, 6, 7, 8, 7&#125;;    int n = sizeof(r) / sizeof(r[0]);    removeDuplicates(r, n);    cout &lt;&lt; &quot;After removing duplicates: &quot;;    for (int i = 0; i &lt; n; i++) &#123;        cout &lt;&lt; r[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;\n 解释\n这段代码实现了一个删除数组中重复元素的算法。它通过循环遍历数组中的每一个元素，并与后面的元素进行比较，如果发现重复的元素，则将后面的元素依次向前移动一位，直到将重复的元素删除。为了减少移动元素的次数，代码从后往前移动元素。最终，剩余元素间的相对次序保持不变。主函数中，我们定义了一个数组 r 和数组长度 n，然后调用 removeDuplicates 函数，将重复元素删除。最后，输出删除重复元素后的数组。该算法的时间复杂度为 O(n^2)，因为需要循环遍历数组中的每一个元素，并与后面的元素进行比较。如果数组中包含大量重复元素，这个算法的效率会很低。\n","categories":["文档区"],"tags":["算法","练习"]},{"title":"stableDiffusion安装roop插件","url":"/2023/07/14/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/2023-07-14_stableDiffusion%E5%AE%89%E8%A3%85roop%E6%8F%92%E4%BB%B6/","content":" stableDiffusion安装roop插件折腾的过程\n 过程\n秋叶版本Stablediffusion的Roop插件的安装_哔哩哔哩_bilibili\n照着这个视频安装完成后，开始运行出现错误\n 错误\nStable Diffusion入门（十三）：深度换脸 | roop - 知乎 (zhihu.com)\n也就是这个教程，第二个错误，下载包不完整\n踩坑：下载buffalo_l.zip以后要解压，把里面的文件放出来到buffalo_l文件夹，要不然一直下载，而且下载速度极慢\n","categories":["文档区"],"tags":["AI","画画","踩坑记录"]},{"title":"StableDiffusion绘制二维码","url":"/2023/07/14/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-07-14_StableDiffusion%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E7%A0%81/","content":" 使用SD结合controlnet模型绘制别样的二维码\n 效果图\n\n 模型\n需要在controlnet中使用该模型\nmonster-labs/control_v1p_sd15_qrcode_monster at main (huggingface.co)\n","categories":["文档区"],"tags":["AI","画画"]},{"title":"本地部署Chat-RWKV-LM","url":"/2023/07/09/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-07-09_%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Chat-RWKV-LM/","content":" 本地离线使用，类Chat GPT工具Chat-RWKV-LM\n\n无需额外付费，使用GPU或CPU进行计算得出结果\n\n RWKV-LM官方GitHub地址：\nhttps://github.com/BlinkDL/RWKV-LM\n RWKV-Runner 启动器GitHub地址：\nhttps://github.com/josStorer/RWKV-Runner\n 部署\n\n下载好启动器，把exe放在一个空文件夹\n运行exe，并随便点击一个模型运行，提示需要python环境，下载即可\n\n 参考视频\n【RWKV-Runner发布并开源，可商用的大语言模型，一键启动管理，2-32G显存适配，API兼容，一切前端皆可用】\nhttps://www.bilibili.com/video/BV1hM4y1v76R/?share_source=copy_web&amp;vd_source=17fc3f0d3cf17f45237a57cc5ba97e0e\n 注意事项\n\n每个模型的所呈现的效果都不用，选择最适合的模型\n\n 模型名称\n例如：GPU-2G-3B-world\n使用GPU计算，显存需要2G，模型参数3B大小，（一般world表示最新的模型）\n","categories":["文档区"],"tags":["AI"]},{"title":"调用非官方GPT的api","url":"/2023/07/09/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-07-09_%E8%B0%83%E7%94%A8%E9%9D%9E%E5%AE%98%E6%96%B9GPT%E7%9A%84api/","content":" 调用api2gpt.com网站提供的镜像GPT的api\n\n因为OPEN AI 的GPT在只能在环大陆地区使用，注册账号并充值很麻烦不稳定，有一定门槛。调用api也需要魔法环境，偶然间发现一个GPTapi提供网站，使用了一下，感觉不错，费用比OPENAI相对便宜调用API时不需要魔法。\n\n 网址：\nhttps://console.api2gpt.com/\n 使用方法\n把openai的接口地址换成https://api.api2gpt.com，然后把Key填入就可以了。其实就是和访问OPEN AI 的接口一样。\n 吐槽：\n我的OPEN AI 账号，7月1日到期了，想充值都没办法充！\n","categories":["文档区"],"tags":["api","AI","GPT"]},{"title":"arduino下载到esp8266报错","url":"/2023/06/13/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/2023-06-13_arduino%E4%B8%8B%E8%BD%BD%E5%88%B0esp8266%E6%8A%A5%E9%94%99/","content":" 错误日志：\nA fatal esptool.py error occurred: Cannot configure port, something went wrong. Original message: PermissionError(13, &#x27;����ϵͳ�ϵ��豸û�з������á�&#x27;, None, 31)\n 解决办法：\n重新安装ch340驱动，（注意需要安装老版本的ch340驱动）\n下载链接：CH341SER.zip - Electropeak\n","categories":["踩坑记录"],"tags":["踩坑记录","arduino"]},{"title":"Stable Diffusion模型-AI画画","url":"/2023/06/09/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-06-09_Stable%20Diffusion%E6%A8%A1%E5%9E%8B-AI%E7%94%BB%E7%94%BB/","content":" 本地电脑安装 Stable Diffusion-AI绘画软件\n[\n 下载整合包\n首先下载“电子菩萨” – 秋葉aaaki  的 整合包\n秋葉aaaki的个人空间_哔哩哔哩_bilibili\n【AI绘画】Stable Diffusion整合包v4发布！全新加速 解压即用 防爆显存 三分钟入门AI绘画 ☆可更新 ☆训练 ☆汉化_哔哩哔哩_bilibili\n 踩坑的问题\n下载下来的整合包.zip 一直解压错误，后来更换下载器重新下载就可以了\n 新知识\n 1.更换绘画模型\n炼丹阁\n\n国内的模型下载网站\n\nHugging Face\n\n国外的模型下载网站\n我也没太弄懂\n\n 2.LoRA模型\nLoRA相当于对图像进行风格化修改\n","categories":["文档区"],"tags":["AI","画画"]},{"title":"webmin工具的安装","url":"/2023/05/23/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-05-23_webmin%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85/","content":" 通过webmin工具远程管理配置服务器\n 安装配置面板 WebMin\n 使用deb包进行安装\n下载路径：http://sourceforge.net/projects/webadmin/files/webmin/\nsudo dpkg -i webmin_1.981_all.deb\n处理依赖关系\nsudo apt install -f\n 启动服务\n开启端口10000\nsudo ufw allow 10000\n重启\nreboot\n登录\nhttps：//服务器 ip：10000","categories":["文档区"],"tags":["Linux"]},{"title":"个人英语词汇数据库","url":"/2023/05/12/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2023-05-12_%E4%B8%AA%E4%BA%BA%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87%E6%95%B0%E6%8D%AE%E5%BA%93/","content":" 使用Microsoft Access 编写的个人单词的数据库，内置查找遗忘单词功能\n\n很简单的一个词汇记忆\n\n 数据库下载地址\nhttps://github.com/UerLink/Vocabulary\n 预览图\n\n","categories":["实践项目"],"tags":["数据库","Access"]},{"title":"Ubuntu安装nginx，部署网站","url":"/2023/04/26/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-04-26_Ubuntu%E5%AE%89%E8%A3%85nginx%EF%BC%8C%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/","content":" Ubuntu系统中安装nginx服务，实现部署网站\n 切换至root用户,并安装nginx\nNginx 在默认的 Ubuntu 源仓库中可用\nsudo apt updatesudo su rootapt-get install nginx\n 查看nginx是否安装成功\nnginx -v\n 运行控制\n 启动nginx\nservice nginx start\n 各种重启\nservice nginx restartsudo systemctl restart nginxnginx -s reload\n 停止\nservice nginx stop\n nginx文件安装完成之后的文件位置：\n/usr/sbin/nginx：主程序\n/etc/nginx：存放配置文件\n/usr/share/nginx：存放静态文件\n/var/log/nginx：存放日志\n 配置网站\n在/etc/nginx/conf.d目录中新建后缀名为 .conf 的空白文件 test.conf\n写入配置表\nserver &#123;    listen       80;    server_name  example.com;    #开启openai接口的gzip压缩，大量重复文本的压缩率高，节省服务端流量    gzip  on;    gzip_min_length 1k;    gzip_types text/event-stream;    #如需部署在网站子路径，如&quot;example.com/chatgpt&quot;，配置如下    #location ^~ /chatgpt/v1 &#123;    location ^~ /v1 &#123;        proxy_pass https://api.openai.com/v1;        proxy_set_header Host api.openai.com;        proxy_ssl_name api.openai.com;        proxy_ssl_server_name on;        #注意Bearer 后改为正确的token。如需网页设置自定义API key使用，则注释掉下一行        proxy_set_header  Authorization &quot;Bearer sk-your-token&quot;;        proxy_pass_header Authorization;        #流式传输，不关闭buffering缓存会卡顿卡死，必须配置！！！        proxy_buffering off;    &#125;    #与上面反代接口的路径保持一致    #location /chatgpt &#123;    location / &#123;        alias /usr/share/nginx/html/;        index index.html;    &#125;&#125;\n检查配置是否生效\nnginx -t\n 配置ssl证书\n参考教程链接：Nginx操作 | Nginx配置SSL证书 - 知乎 (zhihu.com)\n配置完以后要重启\nsudo service nginx restart\n注意ssl认证文件的路径要正确\nserver &#123;    listen 443;    # 你的域名    server_name xxx.cn;    ssl on;    # 你网站的根目录    root /usr/share/nginx/html;     index index.html index.htm;    ssl_certificate  cert/hk.uerlink.cn.pem;    ssl_certificate_key cert/hk.uerlink.cn.key;    ssl_session_timeout 5m;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_prefer_server_ciphers on;&#125;","categories":["文档区"],"tags":[]},{"title":"C++对一元二次求解","url":"/2023/04/18/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-04-18_C++%E5%AF%B9%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%B1%82%E8%A7%A3/","content":" 求解\n\n2023-04-18 保存备份\n\n#include&lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;cmath&gt;using namespace std;int operation_data(int n,int e,int d)&#123;    //定义文件对象    ofstream outFile;    //题目数学公式转换    //n = p * q;    //e * d = (p-1)*(q-1)+1    //-(q*q) + [n+2-(e*d)]*q - n = 0    int a = -1;    double b = (n + 2 - (e * d));    double c = -n;    //求解    double q = (-b + sqrt(b*b - 4*a*c))/2*a;    double p = (-b - sqrt(b*b - 4*a*c))/2*a;    //打开文件    outFile.open(&quot;decode.out&quot;,ios::app);    //判断q和p是否为整数，如果为整数就保存，否则就保存&quot;NO&quot;    //floor() 函数返回不大于给定实数的最大整数    if(q == floor(q) &amp;&amp; p == floor(p))&#123;        cout&lt;&lt;q&lt;&lt;&quot; &quot;&lt;&lt;p&lt;&lt;endl;        outFile &lt;&lt; q &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot;\\n&quot;;    &#125;else&#123;        cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;        outFile &lt;&lt; &quot;NO&quot; &lt;&lt;&quot;\\n&quot;;    &#125;    outFile.close();    return 0;&#125;int main() &#123;    //定义文件对象    ifstream inFile;    ofstream outFile;    string line;    int Column=0;    int Row=0;    int arr[3];    //清空decode.out文件的内容    outFile.open(&quot;decode.out&quot;,ios::trunc);    outFile.close();    //读取文件    inFile.open(&quot;decode.in&quot;, ios::in);    if (!inFile.is_open())    &#123;        cout &lt;&lt; &quot;读取文件失败&quot; &lt;&lt; endl;        return 0;    &#125;else&#123;        //getline可以文件文件内容保存每行的数据到line        while (getline(inFile,line))        &#123;            //使用stringstream            stringstream ss(line);            //读取当前行每列的内容，并保存到数组            Column=0;            while (ss &gt;&gt; arr[Column]) &#123;                Column++;            &#125;            //去除读取文件时开头的0，我也不知道为啥会有个0            if(Row!=0)&#123;                //执行数据计算函数                operation_data(arr[0],arr[1],arr[2]);            &#125;            Row++;        &#125;    &#125;    return 0;&#125;","categories":["文档区"],"tags":[]},{"title":"c++读取和保存数据到文件","url":"/2023/04/18/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-04-18_c++%E8%AF%BB%E5%8F%96%E5%92%8C%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E5%88%B0%E6%96%87%E4%BB%B6/","content":" c++进行读取和保存\n使用fstream和sstream\n#include&lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;using namespace std;int main() &#123;//------------读取文件----------    //定义文件对象    ifstream inFile;    ofstream outFile;    string line;    int arr[3];    inFile.open(&quot;decode.in&quot;, ios::in);    if (!inFile.is_open())    &#123;        cout &lt;&lt; &quot;读取文件失败&quot; &lt;&lt; endl;        return 0;    &#125;else&#123;        //getline可以文件文件内容保存每行的数据到line        while (getline(inFile,line))        &#123;            //使用stringstream            stringstream ss(line);            //读取当前行每列的内容，并保存到数组            int Column=0;            while (ss &gt;&gt; arr[Column]) &#123;                Column++;            &#125;        &#125;    &#125;// --------保存文件----------    ofstream outFile;    //打开文件,ios::app是追加数据    outFile.open(&quot;decode.out&quot;,ios::app);    //存放数据    outFile &lt;&lt;&quot;A&quot;&lt;&lt;&quot; &quot;&lt;&lt;&quot;B&quot;&lt;&lt; &quot;\\n&quot;;    outFile.close();    //清空decode.out文件的内容,ios::trunc    outFile.open(&quot;decode.out&quot;,ios::trunc);    outFile.close();    return 0;&#125;","categories":["文档区"],"tags":[]},{"title":"Linux下搭建frask框架","url":"/2023/04/15/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-04-15_Linux%E4%B8%8B%E6%90%AD%E5%BB%BAfrask%E6%A1%86%E6%9E%B6/","content":" 安装Flask\n 安装python和虚拟环境(venv)\nsudo apt install python3sudo apt install python3-pipsudo apt install python3-venv\n 创建虚拟环境\n\n新建一个空白文件夹，并进入\n\nmkdir flask_app &amp;&amp; cd flask_app\n\n创建一个名为venv的虚拟环境\n\npython3 -m venv venv\n 进入/退出 虚拟环境\n\n进入\n\nsource venv/bin/activate\n\n退出\n\ndeactivate\n 下载Flask\n\n进入虚拟环境，使用pip工具安装flask\n\npip install Flask\n\n验证安装是否成功\n\npython -m flask --version\n 测试\n\n创建一个最小应用程序，下面内容写入名为 main.py 文件\n\nfrom flask import Flask app = Flask(__name__) @app.route(&#x27;/&#x27;) def hello_world(): \treturn &#x27;Hello World!&#x27;\n\n设置FLASK_APP环境变量\n\nexport FLASK_APP=main.py\n\n运行应用\n\nflask run\n\n访问生成的网站，测试完成\n\n","categories":["文档区"],"tags":["Linux","python","框架","frask"]},{"title":"python接入chatgpt的api","url":"/2023/04/15/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-04-15_python%E6%8E%A5%E5%85%A5chatgpt%E7%9A%84api/","content":" 非流式响应\nimport openaiopenai.api_key = &quot;这里放入你的API Key，注意要保留双引号&quot; completion = openai.ChatCompletion.create(  model=&quot;gpt-3.5-turbo&quot;,   messages=[&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;知乎是什么？&quot;&#125;])# 将得到的openai对象转换成python字典  data_json = completion.to_dict()print(data_json)\n 可运行代码\nimport openaiopenai.api_key = &quot;sk&quot;question: str = input(&quot;问题: &quot;)completion = openai.ChatCompletion.create(  model=&quot;gpt-3.5-turbo&quot;,  messages=[&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: question&#125;])# 将得到的openai对象转换成python字典data_json = completion.to_dict()data_json = data_json[&#x27;choices&#x27;][0][&#x27;message&#x27;][&#x27;content&#x27;]print(&quot;AI: &quot; + data_json)\n 流式响应\nimport openaiopenai.api_key = &quot;这里放入你的API Key，注意要保留双引号&quot; completion = openai.ChatCompletion.create(  model=&quot;gpt-3.5-turbo&quot;,   messages=[&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;知乎是什么？&quot;&#125;])# 将得到的openai对象转换成python字典  data_json = completion.to_dict()print(data_json)\n 可运行代码\nimport openai    openai.api_key = &quot;sk-AmHHPxId&quot;  question: str = input(&quot;问题: &quot;)  completion = openai.ChatCompletion.create(  model=&quot;gpt-3.5-turbo&quot;,  stream=True,  messages=[&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: question&#125;]  )    collected_events = [] # 响应接收区  stream_result = &#x27;&#x27; # 保存流式输出的总结果  for event in completion:  collected_events.append(event) # 保存事件响应  data_dict = event.to_dict() # 转换响应为字典  data_openai_object = data_dict[&#x27;choices&#x27;][0] # 获取choices的值  data_json = data_openai_object.to_dict() # 转换openai_object为字典  data_openai_object = data_json[&#x27;delta&#x27;] # 获取delta的值  finish_reason = data_json[&#x27;finish_reason&#x27;] # 获取finish的值,用于判断是否传输结束  data_json = data_openai_object.to_dict() # 转换openai_object为字典  segmental_result = data_json.get(&#x27;content&#x27;, &quot;null&quot;) # 获取content的值，如果没有就返回null    if(segmental_result != &quot;null&quot;): # 判断“分段结果”内是否有内容，有就输出  print(segmental_result, end=&quot;&quot;) # 输出“分段结果“的内容  else:  if (finish_reason == &quot;stop&quot;):  print(&quot;\\n 结束对话&quot;)    \n","categories":["文档区"],"tags":["AI","GPT"]},{"title":"python解析json文件","url":"/2023/04/15/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-04-15_python%E8%A7%A3%E6%9E%90json%E6%96%87%E4%BB%B6/","content":" 导入库\nimport json\n参考学习链接：使用Python读取和解析JSON数据教程 - 知乎 (zhihu.com)\n 解析json\n读取json文件并将json解析为python字典或列表（取决于json文件的内容）\n# 读取json文件并将json解析为python字典data_json = json.load(open(&#x27;txt.json&#x27;))````#### 实用操作操作[字典和列表](../../../../我的笔记/工具语言/Python语言/字典和列表.md)##### strip() 函数```pythonstr = &quot;00000003210Runoob01230000000&quot;; print str.strip( &#x27;0&#x27; ); # 去除首尾字符 0 str2 = &quot; Runoob &quot;; # 去除首尾空格 print str2.strip();\n 获取网址返回的json数据\nimport json  import requests  def json_out():  url = requests.get(&quot;http://127.0.0.1:5000/&quot;)  data = json.loads(url.text)  print(data)    if __name__ == &#x27;__main__&#x27;:  json_out()\n 构造json\n```textimport jsonlanguages = [&quot;English&quot;,&quot;French&quot;]country = &#123;       &quot;name&quot;: &quot;Canada&quot;,       &quot;population&quot;: 37742154,       &quot;languages&quot;: languages,       &quot;president&quot;: None,&#125;country_string = json.dumps(country)print(country_string)\n\n","categories":["文档区"],"tags":["python","json"]},{"title":"服务器Linux配置ssh免登录","url":"/2023/04/14/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-04-14_%E6%9C%8D%E5%8A%A1%E5%99%A8Linux%E9%85%8D%E7%BD%AEssh%E5%85%8D%E7%99%BB%E5%BD%95/","content":" ssh配置免登录\n服务器：Server\n客户端：Client\n 第一步\n在客户端通过 ssh-keygen 命令生成密钥\nssh-keygen -t rsa\n执行完以后直接按回车键 3 次，会在当前用户根目录生成一个 .ssh 文件夹\n 第二步\n拷贝密钥到服务器，有三种方法\n\nssh-copy-id 命令\nscp 命令\n手工复制\n\n这次我们采用“手工复制”的方法，先使用cat命令查看密钥，并复制\ncat ~/.ssh/id_rsa.pub\n 第三步\n然后再登录服务器，将密钥追加的到文件 ~/.ssh/authorized_keys 中去，注意是追加\n最后不出意外就搞定了！\n","categories":["文档区"],"tags":[]},{"title":"文档标签","url":"/2023/04/10/%E6%B5%8B%E8%AF%95%E5%8C%BA/2023-04-10_%E6%96%87%E6%A1%A3%E6%A0%87%E7%AD%BE/","content":" 各种颜色的标签\n 格式\n&#123;% note style %&#125;内容&#123;% endnote %&#125;\n style\nprimary\nsuccess\ninfo\nwarning\ndanger\n","categories":["测试区"],"tags":[]},{"title":"视频嵌入测试","url":"/2023/04/10/%E6%B5%8B%E8%AF%95%E5%8C%BA/2023-04-10_%E8%A7%86%E9%A2%91%E5%B5%8C%E5%85%A5%E6%B5%8B%E8%AF%95/","content":" hexo框架下博客页面嵌入视频\n 嵌入代码\n&lt;div&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=853187459&amp;bvid=BV1AL4y1L7cg&amp;cid=577298153&amp;page=1&amp;high_quality=1&amp;danmaku=0&quot; allowfullscreen=&quot;allowfullscreen&quot; width=&quot;100%&quot; height=&quot;450&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; framespacing=&quot;0&quot; sandbox=&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;\n 视频\n\n因网络原因可能导致视频加载缓慢\n\n 视频1\n\n\n\n 视频2\n\n\n\n","categories":["测试区"],"tags":[]},{"title":"Linux软件安装与卸载","url":"/2023/04/10/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-04-10_Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/","content":" 软件包分类\nLinux 安装包主要有两种：\nUbuntu 和 Debian 使用的是 .deb 格式的安装包\nred hat centos 使用的是 .rpm 格式的安装包\n 软件包管理器\nUbuntu 和 Debian 使用的管理器是 apt\nred hat centos 使用的管理器是 yum\nUbuntu 现在还推荐使用一种新的管理器 snap\n atp命令行\n命令：apt update   —获取最新软件包列表, 同步sources.list\n命令：apt upgrate  —更新当前系统所有安装的软件包和相关依赖\n命令：apt install  —下载并安装软件包\n命令：apt remove  —卸载软件包\n命令：apt purge —卸载软件包，并删除配置文件\n命令：apt list  —列出包含条件的软件包\n命令：apt show  —显示软件包详情信息\n命令：apt search  —搜索应用程序\n 换源\nvi /etc/apt/sources.list\n dpkg包\n\ndpkg本身是一个底层工具，而APT则是位于上层的工具\n\n 安装\n命令：dpkg -i 软件包名  —安装Deb软件包\n 卸载\n命令：dpkg -r 软件包名  —卸载Deb软件包\n命令：dpkg -p 软件包名  —卸载Deb软件包，并删除配置信息\n 其他\n命令：sudo apt --fix-broken install   —自动完成依赖关系的处理\n命令：dpkg -l  软件包名  —查询指定软件包\n命令：dpkg -s 软件包名   —查询指定软件包的详细说明\n Snap包\n\n是针对Linux和物联网设计的，类似一个容器，完全独立与系统\n\n 安装\n命令：snap install 软件包名  --安装Snap软件包\n命令：snap refresh 软件包名  --手动更新软件Snap软件包\n 其他\n命令：snap list  —列出采用Snap包的应用软件\n命令：snap find 软件包名  —搜索snap软件包\n命令：snap info 软件报名  —查询指定软件包的详情信息\n 解压包\n以下是一些常见的Linux解压命令：\n命令：tar -xvf filename.tar    —解压tar文件\n命令：tar -xzvf filename.tar.gz   —解压gzip格式的tar文件\n命令：tar -xjvf filename.tar.bz2  ----解压bzip2格式的tar文件\n命令：unzip filename.zip    ----解压zip文件\n命令：unrar x filename.rar    ----解压rar文件\n 源代码安装\n 编译\n命令：sudo make   —使用命令 make 在当前文件夹进行编译\n\nmake 会依据 Makefile 文件的设置，将源代码编译成可执行的二进\n制文件\n\n 安装\n命令：sudo make install   —安装makefile中设置，安装到指定文件夹\n\n多数源码安装包会提供一个 configure 文件，用来自动检测操作环\n境，并可生 成 Makefile 文件\n在当前文件夹执行此命令 ./configure\n\n 卸载\n命令：sudo make uninstall  —卸载\n命令：sudo make clean  —卸载\n checkinstall 命令\n\ncheckinstall 是一个能将源代码制作成安装包的程序，并自动安装\n\nsudo apt install checkinstall\n命令：sudo checkinstall  —安装并生成deb安装包\n","categories":["文档区"],"tags":[]},{"title":"Linux翻译api接入终端","url":"/2023/03/27/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-03-27_Linux%E7%BF%BB%E8%AF%91api%E6%8E%A5%E5%85%A5%E7%BB%88%E7%AB%AF/","content":" 目录结构\n\nfy.php\nfy.sh#\n\n github地址\nhttps://github.com/UerLink/Terminal-small-tools\n 请安装php环境\nsudo apt-get install php\n fy.php\n\napi使用的是https://api.vvhan.com/fanyi.html\n\n&lt;?phpheader(&quot;Content-Type:text/json;charset=UTF-8&quot;);$info = $argv[1];$json_string = file_get_contents(&quot;https://api.vvhan.com/api/fy?text=&quot; . $info);$decoded_data = json_decode($json_string, true);$fanyi = $decoded_data[&#x27;data&#x27;][&#x27;fanyi&#x27;];echo &quot;\\033[34m⇢\\033[0m  $fanyi  \\033[34m⇠ 翻译结果\\033[0m&quot;;?&gt;\n fy.sh\n#!/bin/bashif [ -n &quot;$1&quot; ]then \tinfo=$1\tphp fy.php &quot;$info&quot;else\techo -e &quot;\\033[32m[提示]\\033[0m \\033[34m命令格式：\\033[0m fyy 要翻译的内容&quot;fi\n 使用方式\n 方式一\n终端中输入  ./fy.sh 要翻译的内容\n 方式二\n\n把fy.sh中的php fy.php “$info” 的路径改成绝对路径\n添加权限\n\nchown  root:root fy.sh\n\n再移动fy.sh文件\n\nsudo mv fy.sh /usr/bin/fy\n\n之后就可以直接在终端中输入 fy 内容\n\n","categories":["文档区"],"tags":["api"]},{"title":"ChatGPT镜像网站","url":"/2023/03/25/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-03-25_ChatGPT%E9%95%9C%E5%83%8F%E7%BD%91%E7%AB%99/","content":" ChatGPT为OPENAI开发的人工智能，是一个非常好用的工具\n下列网站除去API网站和官网，其他全部已经失效了还是推荐国内“文心一言”，“通义千问” 等AI\n 官网\n\n需要魔法，才能访问\n\nhttps://chat.openai.com/chat\nhttps://platform.openai.com/account/api-keys\n 镜像api网站（推荐）\nApi2Gpt | Api2Gpt（可以无需魔法使用chatgpt的api接口，目前我正在使用的也是这个，我的openai账号到期了，懒得搞了）\n 免登录，速度还行\n\n有几个可以用api-key，不填也基本上可以用\n\nhttps://chatmindai.cn（已失效）\nhttps://chat.gpt.bz/gpt/（已失效）\nhttps://www.ourfpv.com/chat/（已失效）\nhttps://chat.cutecloud.link/（已失效）\nhttp://www.tdchat4.com/（已失效）\nhttps://chat35.com/chat（已失效）\nhttps://ai.meiko.ink/（已失效）\nhttps://chat.lkong.org/（已失效）\n 需要api-key\nhttps://chat.forchange.cn/（已失效）\nhttp://itecheasy.com.cn/（已失效）\nhttps://ai.yiios.com/（已失效）\n 需要登录\n\n不推荐使用\n\nhttps://chat.zecoba.cn/（已失效）\nhttps://chat.eaten.fun/（已失效）\nhttps://chat.paoying.net/（已失效）\nhttps://chat.alpaca-bi.com/（已失效）\nhttps://chat.qingting.work/（已失效）\n\n\n","categories":["文档区"],"tags":["AI","ChatGPT"]},{"title":"博客添加新的菜单栏","url":"/2023/03/23/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-03-23_%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E8%8F%9C%E5%8D%95%E6%A0%8F/","content":" 博客添加新的菜单栏\n\n例如添加 test 菜单栏\n\n\n在_config.yml文件中添加新的菜单项\n\nmenus:  home: /  books: /books  progress: /progress  categories: /categories  archive: /archives  friends: /links    test: /test\n\n在source文件夹中添加 test 文件夹，文件夹中添加index.md 文件\n\n文件内容：\n---title: testlayout: test---\n\n在zh-CN.yml和en.yml文件中添加 翻译\n\n","categories":["文档区"],"tags":[]},{"title":"安卓app内嵌网页","url":"/2023/03/12/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-03-12_%E5%AE%89%E5%8D%93app%E5%86%85%E5%B5%8C%E7%BD%91%E9%A1%B5/","content":" app内嵌网页\n 申请网络权限\n\n在 AndroidManifest.xml 文件中添加获取权限\n\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;\n 放置Web控件\n&lt;WebView      android:id=&quot;@+id/web&quot;      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;match_parent&quot;/&gt;\n 调用网页\npublic WebView webView;//以下代码在onCreate()之内webView = (WebView) findViewById(R.id.web);  webView.setWebViewClient(new WebViewClient()&#123;      @Override      public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;          view.loadUrl(url);          return true;    &#125;  &#125;);  webView.getSettings().setJavaScriptEnabled(true);  //允许使用jswebView.loadUrl(&quot;https:/a.com&quot;);","categories":["文档区"],"tags":["Android"]},{"title":"解决jupyter中pandas导入excel时没有openpyxl 库的错误","url":"/2023/03/08/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/2023-03-08_%E8%A7%A3%E5%86%B3jupyter%E4%B8%ADpandas%E5%AF%BC%E5%85%A5excel%E6%97%B6%E6%B2%A1%E6%9C%89openpyxl%20%E5%BA%93%E7%9A%84%E9%94%99%E8%AF%AF/","content":" 在学习python时出现的错误\n解决jupyter中pandas导入excel时没有openpyxl 库的错误\n 方法\n在jupyter命令行中输入并运行\npip install -U openpyxl -i https://pypi.douban.com/simple\n","categories":["踩坑记录"],"tags":["python","踩坑记录"]},{"title":"C++指针易错知识点","url":"/2023/01/04/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023-01-04_C++%E6%8C%87%E9%92%88%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"int a=1;int *p=&amp;a;  //定义一个指向a变量地址的指针p //表示指针的名字*p //表示指针所指向的内容，*p 也就等同于 a&amp;p //指针p的地址，注意不是指向的地址。&amp;a //变量a的地址int *p=&amp;a; //声明指针*p=&amp;a; //这样是不行的，这种结构只能在声明指针变量的时候使用\t   //如果要把另一个变量的地址赋值都指针中，应该写出p=&amp;b;*p1=*p2; //表示把p1指针所指向的值更改为p2指针所指向的值p1=p2; //表示把P1指向的地址（存储在指针中的地址）更改为P2指向的地址*p1=p2;  //错误p1=*p2;  //错误  //p1是指针a=*p2;  //表示把p2所指向的值赋值给a变量，  a是变量\n this指针：\n每个成员函数中都包含一个特殊的指针，就是this指针\n哪个对象调用了这个函数，this指针就指向这个对象\n","categories":["文档区"],"tags":["C++"]},{"title":"更新测试","url":"/2023/01/02/%E6%B5%8B%E8%AF%95%E5%8C%BA/2023-01-02_%E6%9B%B4%E6%96%B0%E6%B5%8B%E8%AF%95/","content":" 此页面用于测试博客是否正常更新\n 2023-08-05\n 2023-01-02\n好久没写博客了,发布篇测试文章 ,用于测试博客上传GitHub是否正常!\n看到这篇文章 ,证明一切顺利.\n\n 2024-03-16\n更新正常\n表格测试：\n\n\n\n星期一\n星期二\n星期三\n星期四\n\n\n\n\n100\n23\n12\n23\n\n\n\n","categories":["测试区"],"tags":[]},{"title":"C++使用SOCKET进行通信","url":"/2022/10/28/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-10-28_C++%E4%BD%BF%E7%94%A8SOCKET%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1/","content":" SOCKET通信:\n 所需头文件和函数\n 头文件\n#include &lt;iostream&gt;#include &lt;winsock2.h&gt; //socket头文件#pragma comment(lib,&quot;ws2_32.lib&quot;) //导入静态链接库\n 函数\n 服务器端\nsocket()//生成SOCKET对象，并指定（地址族，socket类型，指定协议）\tSOCKET S_socket = socket(AF_INET, SOCK_STREAM, 0);bind()//把结构体中地址的信息，组合好传递给套接字（套接字对象，结构体信息的指针，结构体信息的长度）,返回0表示绑定成功     bind(listen_socket, (SOCKADDR*)&amp;S_sockaddr, sizeof(SOCKADDR));listen()//监听套接字（套接字对象，最大连接数）\tlisten(listen_socket, 10);accept()//将连接到服务器的客户端地址信息存储到，结构体中和SOCKET中\tC_socket = accept(listen_socket, (SOCKADDR*)&amp;C_sockaddr, &amp;len);send()//将缓冲区内的数据通过套接字发送出去（SOCKET对象，缓存变量，字节长度，默认行为0）\tsend(C_socket, send_buf, 100, 0);\trecv()//将soctet缓冲区内的数据读取出来保存到对应变量（SOCKET对象，存储变量，读取字节数，行为默认0）\trecv(C_socket, recv_buf, 100, 0);#### 客户端socket()inet_addr()把IP地址进行转换，以便保存在结构体中（winsock2.h不可用，winsock.h可用）htons()connect()//连接服务器（服务器SOCKET对象，服务器SOCKET地址，服务器SOCKET地址长度）\tconnect(S_socket, (SOCKADDR*)&amp;S_sockaddr, sizeof(SOCKADDR))\tsend()recv()\n SOCKET初始化\nvoid initSocket() &#123;    //初始化套接字库    WORD w_req = MAKEWORD(2, 2);//版本号    WSADATA wsadata;    int err;    err = WSAStartup(w_req, &amp;wsadata);    if (err != 0) &#123;        cout &lt;&lt; &quot;初始化套接字库失败&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;初始化套接字库成功&quot; &lt;&lt; endl;    &#125;    //检测版本号    if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) &#123;        cout &lt;&lt; &quot;套接字库版本号不符&quot; &lt;&lt; endl;        WSACleanup();    &#125;    else &#123;        cout &lt;&lt; &quot;套接字库版本正确&quot; &lt;&lt; endl;    &#125;&#125;\n 全部代码\n 服务器端\n#include &lt;iostream&gt;#include &lt;winsock2.h&gt;//导入静态链接库#pragma comment(lib,&quot;ws2_32.lib&quot;)using namespace std;void initSocket();  //声明套接字初始化函数int main()&#123;    //执行套接字初始化函数    initSocket();    //生成用于监听的SOCKET对象，并指定（地址族，socket类型，指定协议）    SOCKET listen_socket = socket(AF_INET, SOCK_STREAM, 0);    //创建存储套接字地址信息的结构体    SOCKADDR_IN S_sockaddr;    S_sockaddr.sin_family = AF_INET;    //设置地址族    S_sockaddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//设置IP地址，htonl    S_sockaddr.sin_port = htons(9966); //设置端口号    /*        INADDR_ANY表示任何地址，也就是不指定具体IP地址        htons()把short型值转成按网络字节顺序排列的short型值        htonl()把long型值转成按网络字节顺序排列的long型值    */    //把结构体中地址的信息，组合好传递给套接字（套接字对象，结构体信息的指针，结构体信息的长度）    if (0 == bind(listen_socket, (SOCKADDR*)&amp;S_sockaddr, sizeof(SOCKADDR))) &#123;           cout &lt;&lt; &quot;套接字绑定信息成功&quot;&lt;&lt;endl;    &#125;    else &#123;          cout &lt;&lt; &quot;套接字绑定信息失败&quot;&lt;&lt;endl;        WSACleanup();//释放DLL资源    &#125;    //监听套接字（套接字对象，最大连接数）    if (listen(listen_socket, 10) &lt; 0) &#123;        cout &lt;&lt; &quot;设置监听状态失败&quot; &lt;&lt; endl;        WSACleanup();    &#125;    else &#123;        cout &lt;&lt; &quot;设置监听状态成功&quot; &lt;&lt; endl;    &#125;    //创建客户端的SOCKET对象    SOCKET C_socket;    //创建用于存储客户端地址的结构体    SOCKADDR_IN C_sockaddr;    int len = sizeof(SOCKADDR);    //将连接到服务器的客户端地址信息存储到，结构体中    C_socket = accept(listen_socket, (SOCKADDR*)&amp;C_sockaddr, &amp;len);    //判断客户端是否连接成功    if (C_socket == SOCKET_ERROR) &#123;        cout &lt;&lt; &quot;客户端连接失败&quot; &lt;&lt; endl;        WSACleanup();        return 0;    &#125;    else    &#123;        cout &lt;&lt; &quot;客户端连接成功&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl;        int recv_len = 0;        int send_len = 0;        //定义发送缓冲区和接受缓冲区        char recv_buf[100];        char send_buf[100];        while (1) &#123;             //将soctet缓冲区内的数据读取出来保存到对应变量（SOCKET对象，存储变量，读取字节数，行为默认0）            recv_len = recv(C_socket, recv_buf, 100, 0);            if (recv_len &lt; 0) &#123;                cout &lt;&lt; &quot;接收数据失败&quot; &lt;&lt; endl;                break;            &#125;            else &#123;                cout &lt;&lt; &quot;客户端:&quot; &lt;&lt; recv_buf &lt;&lt; endl;            &#125;            /*            cout &lt;&lt; &quot;请输入:&quot;;            cin &gt;&gt; send_buf;            //将缓冲区内的数据通过套接字发送出去（SOCKET对象，缓存变量，字节长度，默认行为0）            send_len = send(C_socket, send_buf, 100, 0);            if (send_len &lt; 0) &#123;                cout &lt;&lt; &quot;发送失败！&quot; &lt;&lt; endl;                break;            &#125;            */        &#125;    &#125;    /*    //关闭套接字    closesocket(S_socket);    closesocket(C_socket);    //释放DLL资源    WSACleanup();    */    return 0;&#125;void initSocket() &#123;    //初始化套接字库    WORD w_req = MAKEWORD(2, 2);//版本号    WSADATA wsadata;    int err;    err = WSAStartup(w_req, &amp;wsadata);    if (err != 0) &#123;        cout &lt;&lt; &quot;初始化套接字库失败&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;初始化套接字库成功&quot; &lt;&lt; endl;    &#125;    //检测版本号    if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) &#123;        cout &lt;&lt; &quot;套接字库版本号不符&quot; &lt;&lt; endl;        WSACleanup();    &#125;    else &#123;        cout &lt;&lt; &quot;套接字库版本正确&quot; &lt;&lt; endl;    &#125;&#125;\n\n 客户端\n#include &lt;iostream&gt;#include&lt;WinSock.h&gt;//导入静态链接库#pragma comment(lib,&quot;ws2_32.lib&quot;)using namespace std;void initSocket();//声明SOCKET初始化函数int main()&#123;    //执行SOCKET初始化函数    initSocket();    //生成SOCKET对象，并指定（地址族，socket类型，指定协议）    SOCKET S_socket = socket(AF_INET, SOCK_STREAM, 0);    //创建存储套接字地址信息的结构体    SOCKADDR_IN S_sockaddr;    S_sockaddr.sin_family = AF_INET;    //设置地址族    S_sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//设置IP地址，inet_addr    S_sockaddr.sin_port = htons(9966); //设置端口号    //连接服务器（客户端SOCKET对象，服务器SOCKET地址，服务器SOCKET地址长度）    if (connect(S_socket, (SOCKADDR*)&amp;S_sockaddr, sizeof(SOCKADDR)) == SOCKET_ERROR) &#123;        cout &lt;&lt; &quot;服务器连接失败&quot; &lt;&lt; endl;        WSACleanup();    &#125;    else &#123;        cout &lt;&lt; &quot;服务器连接成功&quot; &lt;&lt; endl;        char send_buf[100];        char recv_buf[100];        int send_len = 0;        int recv_len = 0;        while (1) &#123;            cout &lt;&lt; &quot;请输入:&quot;;            cin &gt;&gt; send_buf;            send_len = send(S_socket, send_buf, 100, 0);            if (send_len &lt; 0) &#123;                cout &lt;&lt; &quot;发送失败！&quot; &lt;&lt; endl;                break;            &#125;            /*            recv_len = recv(S_socket, recv_buf, 100, 0);            if (recv_len &lt; 0) &#123;                cout &lt;&lt; &quot;接收数据失败&quot; &lt;&lt; endl;                break;            &#125;            else &#123;                cout &lt;&lt; &quot;客户端:&quot; &lt;&lt; recv_buf &lt;&lt; endl;            &#125;            */        &#125;    &#125;    return 0;&#125;void initSocket() &#123;    //初始化套接字库    WORD w_req = MAKEWORD(2, 2);//版本号    WSADATA wsadata;    int err;    err = WSAStartup(w_req, &amp;wsadata);    if (err != 0) &#123;        cout &lt;&lt; &quot;初始化套接字库失败&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;初始化套接字库成功&quot; &lt;&lt; endl;    &#125;    //检测版本号    if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) &#123;        cout &lt;&lt; &quot;套接字库版本号不符&quot; &lt;&lt; endl;        WSACleanup();    &#125;    else &#123;        cout &lt;&lt; &quot;套接字库版本正确&quot; &lt;&lt; endl;    &#125;&#125;","categories":["文档区"],"tags":["通信","C++"]},{"title":"手工PCB制作实验日志记录","url":"/2022/10/24/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2022-10-24_%E6%89%8B%E5%B7%A5PCB%E5%88%B6%E4%BD%9C%E5%AE%9E%E9%AA%8C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/","content":" 采用热转印对铺铜板进行刻蚀达到手工制作PCB的目的\n推荐教程：热转印手工pcb教程\n 实验/学习日志记录\n 第一次实验\n\n2022-10-24\n\n\n 实验结果：\n画线处铜板未完全刻蚀（背面完全刻蚀）\n 还需改进：\n\n墨粉未清除干净（用刷衣服的刷子刷的）\n画线前未清除铜板氧化层\n刻蚀溶液未按比例配置\n铜板放置正反不对\n\n 第二次实验\n\n2022-10-24\n\n\n 实验结果：\n画线处存在漏点破损\n 还需改进：\n\n画线时应该涂均匀\n放置的时候正向放置，以免墨被挂掉，导致线路被刻蚀\n\n","categories":["实践项目"],"tags":["PCB","手工"]},{"title":"Linux终端快捷小工具","url":"/2022/09/28/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2022-09-28_Linux%E7%BB%88%E7%AB%AF%E5%BF%AB%E6%8D%B7%E5%B0%8F%E5%B7%A5%E5%85%B7/","content":" 终端快捷小工具（Terminal-small-tools）\n\n一些终端可以快捷使用的小工具，但个人水平有限(初学者),所以功能很少。\n\n 下载地址\n链接：https://github.com/UerLink/Terminal-small-tools\n 当前工具列表\n\n\n 终端快捷翻译\n\n\n\n 终端快捷命令\n\n\n\n 安装与卸载方法\n 安装\n在项目根目录中运行 install.sh 文件\n./install.sh\n 卸载\n在项目根目录中运行 uninstall.sh 文件\n./uninstall.sh\n 运行失败解决\n\n快捷翻译需要安装php环境\n\nsudo apt-get install php\n\n快捷命令添加自定义命令后运行失败,请尝试添加 sudo 运行\n\nsudo run 编号","categories":["实践项目"],"tags":["Linux","工具"]},{"title":"Linux创建并管理用户","url":"/2022/09/26/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-09-26_Linux%E5%88%9B%E5%BB%BA%E5%B9%B6%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7/","content":" 创建用户名和密码\nsudo useradd -m &lt;用户名&gt;\n\n-m 　自动建立用户目录。\n\nsudo passwd  &lt;用户名&gt; # 之后输入两次密码\n 切换用户\nsu &lt;用户名&gt;\n如果是新装系统，切换到su root时候报错（su: Authentication failure），就输入sudo passwd root设置root的密码。\n 给予权限\nsudo vim /etc/sudoers\n在user privilege这一项进行修改\n 删除用户\nsudo userdel -r &lt;用户名&gt;\n 连接远程用户\n使用ssh连接工具，Windows自带的PowerShell也可以\nssh uerlink@120.20.200.200   # 输入你的用户名和远程服务器的ip\n如果每次使用ip连接，又没有国内备案的域名。就可以修改window的host文件添加本地域名解析到ip。\n 退出用户登录\nctrl + d 或者 exit\n Linux设置默认启动用户\n在PowerShell中输入\ndebian config --default-user root\n😁\n","categories":["文档区"],"tags":["Linux"]},{"title":"Linux子系统远程访问","url":"/2022/09/26/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-09-26_Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/","content":" 安装ssh服务\napt-get remove openssh-server\napt-get install openssh-server\n 编辑sshd_config文件\nvim /etc/ssh/sshd_config\nPort 2222  #&gt;设置ssh的端口号, 由于22在windows中有别的用处, 尽量不修改系统的端口号PermitRootLogin yes   #&gt;可以root远程登录PasswordAuthentication yes     #&gt;密码验证登录\n 重启服务\nsudo service ssh --full-restart\n 启动ssh\nsudo service sshd start\n 内网穿透\n把子系统的ip地址做映射\n有公网ip就不用啦，没有就用花生壳之类的软件\n 固定ip地址\n因为wsl2以后，每次重新启动时候。Linux子系统会随机分配ip，然后内外穿透的ip就解析不到Linux的ip和端口\n 解决办法\n创建一个脚本在Windows开机以后，分配一个固定的虚拟ip给Linux子系统，然后解析到虚拟ip上面\n1.bat脚本\n\n把debian替换成你自己的系统，ip默认是192.168.50.16（可以自己改）\n\n::强制获取管理员运行权限%1 mshta vbscript:CreateObject(&quot;Shell.Application&quot;).ShellExecute(&quot;cmd.exe&quot;,&quot;/c %~s0 ::&quot;,&quot;&quot;,&quot;runas&quot;,1)(window.close)&amp;&amp;exitwsl -d debian -u root ip addr add 192.168.50.16/24 broadcast 192.168.50.255 dev eth0 label eth0:1netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.50.88 255.255.255.0\n2.把bat脚本放在Windows启动目录\n%programdata%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n 另一个问题\nssh连接内网穿透的域名，你可能还是无法使用，是因为Linux的ssh没有启动，你可以设置开机启动。\n 开机自启ssh\nsudo systemctl enable ssh\nsudo /etc/init.d/ssh start\n ssh连接\nssh fzl@120.12.1.21 -p2222\n\n-p后面是端口号\n\nhostname -I\n\n显示linux系统的ip地址\n\n\n\n😁\n\n\n","categories":["文档区"],"tags":["Linux"]},{"title":"Linux运行C++程序","url":"/2022/09/25/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-09-25_Linux%E8%BF%90%E8%A1%8CC++%E7%A8%8B%E5%BA%8F/","content":" 运行C++程序\n 安装gcc包\nsudo apt install build-essential\ngcc --version # 查看是否安装成功\n 安装失败\n有可能是镜像源的问题，使用下面的应该能成功\ndeb http://mirrors.cloud.tencent.com/debian/ bullseye main non-free contribdeb http://mirrors.cloud.tencent.com/debian-security bullseye/updates maindeb http://mirrors.cloud.tencent.com/debian/ bullseye-updates main non-free contribdeb http://mirrors.cloud.tencent.com/debian/ bullseye-backports main non-free contribdeb-src http://mirrors.cloud.tencent.com/debian-security bullseye/updates maindeb-src http://mirrors.cloud.tencent.com/debian/ bullseye main non-free contribdeb-src http://mirrors.cloud.tencent.com/debian/ bullseye-updates main non-free contribdeb-src http://mirrors.cloud.tencent.com/debian/ bullseye-backports main non-free contrib\n 编写代码\n直接vim里面写就可以了\nvim test.cpp\n using：函数\n 编译代码\ng++ test.cpp -o test   # -o后面表示生成可执行文件名\ng++ test.cpp # 这样直接编译也行，只不过可能会找不到\n 运行代码\n在可执行文件的文件夹下：\n./test   # ./后面写可执行文件名\n","categories":["文档区"],"tags":["Linux","C++"]},{"title":"Linux配置git","url":"/2022/09/25/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-09-25_Linux%E9%85%8D%E7%BD%AEgit/","content":" 配置git\n 下载git\nsudo apt-get install git\n 初始化git\ngit config --global user.name “名字”\ngit config --global user.email 邮箱\n//–global 表示全局配置\n 常用git命令\n","categories":["文档区"],"tags":["Linux","git"]},{"title":"Vim编辑器常用命令","url":"/2022/09/25/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-09-25_Vim%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"x 删除光标后一个字符\nd + ←→删除光标←→字符（d +3←）、dd删除一行（其实是剪切，p粘贴）\ny+ ←→复制光标←→字符 （y+3←）\nc 删除并进入写入模式、w 光标向下移动一个词、cw删除一个词并进入写入模式、b光标到上一个词 、ciw词中删除一个词并进入写入模式，yi\nf 找词\n/ 搜索、n下 N上\n【y i c d f 】\nesc 回到正常模式\n：w保存\n：q退出vim\n：source $MYVIMRC 刷新vim\njkhl上下左右\n：split 上下分屏 、：vsplit 左右分屏 Q退出\n~/.vim/vimrc\nnoremap a b a键改b键\nmap a b a键改b键\nsyntax on 打开高亮\nset number 显示行号\nset wildmenu ：命令补全\nset hlsearch /搜索高亮\nset incsearch 一面输入一面高亮\n","categories":["文档区"],"tags":["Vim"]},{"title":"Linux安装vim","url":"/2022/09/24/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-09-24_Linux%E5%AE%89%E8%A3%85vim/","content":" 安装vim\n用的是debian系统\n 更新系统镜像源\nsudo cp /etc/apt/sources.list /etc/apt/sources.list_bak # 备份一下软件源\nsudo vi /etc/apt/sources.list\n如果是vi编辑器就进入list文件后直接 “:.,$d” 清空文件，然后粘贴下面的镜像源\n按esc，然后输入 “:wq” 保存并退出\ndeb http://mirrors.cloud.tencent.com/debian/ bullseye main non-free contribdeb http://mirrors.cloud.tencent.com/debian-security bullseye/updates maindeb http://mirrors.cloud.tencent.com/debian/ bullseye-updates main non-free contribdeb http://mirrors.cloud.tencent.com/debian/ bullseye-backports main non-free contribdeb-src http://mirrors.cloud.tencent.com/debian-security bullseye/updates maindeb-src http://mirrors.cloud.tencent.com/debian/ bullseye main non-free contribdeb-src http://mirrors.cloud.tencent.com/debian/ bullseye-updates main non-free contribdeb-src http://mirrors.cloud.tencent.com/debian/ bullseye-backports main non-free contrib\n 更新镜像\nsudo apt-get update\nsudo apt-get upgrade\n 安装软件\napt-get install vim\n 报错解决\nsudo apt-get purge vim-common\nsudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install vim\n","categories":["文档区"],"tags":["Linux","Vim"]},{"title":"《中国太阳》","url":"/2022/08/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2022-08-19_%E4%B8%AD%E5%9B%BD%E5%A4%AA%E9%98%B3/","content":" 记得仰望星空！！！\n这本书，节奏很快。一个仅上个过3年小学的，农村小伙子。到最后驾驶着由“中国太阳“改造后的飞船，向着太阳系之外探索。\n”这个世界机遇很多，天上到处都是金色的飞鸟“\n”不要丢失，探索宇宙的目标“\n","categories":["读书笔记"],"tags":["读书笔记"]},{"title":"《时间的秩序》","url":"/2022/08/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2022-08-19_%E6%97%B6%E9%97%B4%E7%9A%84%E7%A7%A9%E5%BA%8F/","content":" 内容介绍：\n在我们的直觉里，时间是全宇宙统一的，稳定地从过去流向未来，可以用钟表度量。可罗韦利向我们揭示出一个奇怪的宇宙，在这里，时间的特质一一坍塌，在基本的层面上，时间消失了。他告诉我们，我们对时间流逝的感知，取决于我们的视角……\n\n\n        \n            \n        \n        \n            《时间的秩序》\n        \n\n\n 语录\n\n在进步的历程中，我们认识到，一些看似不证自明的事，实际上仅仅是偏见。天空在我们之上而非之下，这似乎显而易见，不然地球就会坠落。地球静止不动似乎是不言而喻的，否则它就会让一切都撞毁。时间在任何地方都以同样的速度流逝，对我们来说也同样是显而易见的……孩子会长大，发现小时候从四壁之家望出去看到的并不是世界的全貌，作为共同体的人类也是一样。\n为什么我们记得过去，而非未来？是我们存在于时间之内，还是时间存在于我们之中？说时间“流逝”到底意味着什么？是什么把时间与我们作为人的本性，与我们的主观性联系在一起？\n\n 感想\n 疑问\n","categories":["读书笔记"],"tags":["读书笔记"]},{"title":"3d模型嵌入测试","url":"/2022/07/17/%E6%B5%8B%E8%AF%95%E5%8C%BA/2022-07-17_3d%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%85%A5%E6%B5%8B%E8%AF%95/","content":" hexo框架下博客页面嵌入3D模型\n\n模型网站：&quot;https://hub.realibox.com/\n\n 嵌入代码\n&lt;div&gt;&lt;iframe src=&quot;https://hub.realibox.com/public/2355827666029903955&quot; width=&#x27;100%&#x27; height=&#x27;600&#x27; frameborder=&#x27;no&#x27; allowfullscreen=&#x27;true&#x27;&gt;&lt;/iframe&gt;&lt;/div&gt;\n 模型预览：\n\n\n\n 模型分享：\n\n此3D模型&nbsp;&nbsp;&nbsp;&nbsp;下载\n","categories":["测试区"],"tags":[]},{"title":"读书技巧","url":"/2022/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2022-06-20_%E8%AF%BB%E4%B9%A6%E6%8A%80%E5%B7%A7/","content":" 新手读书技巧\n\n专业性书籍和文学性书籍分开时间段读\n读书的第一个阶段是养成习惯, 选择自己能够较为轻松理解的书籍阅读\n不要刻意的去学习读书方式/方法, 读书的方法是在长时间的习惯中养成的, 适合自己的才是最好的\n\n 2022-06-21\n\n看书或者做事, 都应该计算好每一件事, 所需要的时间, 以便于我们能够更好的合理的安排时间\nT型读书法, H型读书法\n\n","categories":["读书笔记"],"tags":["读书笔记"]},{"title":"php连接数据库并执行sql语句查询","url":"/2022/06/16/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-06-16_php%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5%E6%9F%A5%E8%AF%A2/","content":" php连接数据库并执行sql语句查询：通过html表单提交数据给php\n 效果图\n\n\n\t\n\t\t\n\t\t登录\n\t\n\t\n\t\t\n\t\t\t用户名:\n\t\t\t\n\t\t\t\n\t\t\t密码:\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t \n\t\n\n ---\n 全部文件\n\nindex.php\nindex.html\n\n index.php文件代码:\n\n&lt;?PHP    $date_db=&#x27;test1&#x27;;    $conn=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);//连接字符串    $comm=mysqli_select_db($conn,$date_db);//利用连接字符串选择数据库    $username = addslashes($_POST[&#x27;username&#x27;]);//得到数据    $password = addslashes($_POST[&#x27;password&#x27;]);//得到数据        $sql_data=&quot;select * from users where userName=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;//sql查询语句赋值给变量    $query= mysqli_query($conn,$sql_data);//利用连接字符串运行sql语句            if($conn)&#123;        echo&quot;--连接MySQL成功--&quot;;            &#125;    else&#123;        echo&quot;--连接MySQL失败--&quot;;        &#125;        if($comm)&#123;        echo&#x27;--连接数据库:&#x27;;        echo $date_db;        echo&#x27;成功--&#x27;;    &#125;     if( mysqli_num_rows($query)&gt;0)&#123;        echo&quot;&lt;br&gt;&quot;;        echo $sql_data;        echo&#x27;----查询成功--&#x27;;    &#125;    else&#123;                       $url=&#x27;index.html&#x27;;       echo &quot;&lt;script&gt;location.href=&#x27;$url&#x27;&lt;/script&gt;&quot;;//跳转指定网页                      echo&quot;&lt;br&gt;&quot;;        echo $sql_data;                echo&#x27;----语句查询失败--&#x27;;    &#125;?&gt;\n index.html文件代码：\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;登录&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;form action=&quot;index.php&quot; method=&quot;post&quot;&gt;\t\t\t用户名:&lt;br&gt;\t\t\t&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;UerLink&quot;&gt;\t\t\t&lt;br&gt;\t\t\t密码:&lt;br&gt;\t\t\t&lt;input type=&quot;text&quot; name=&quot;password&quot; value=&quot;123456&quot;&gt;\t\t\t&lt;br&gt;&lt;br&gt;\t\t\t&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;\t\t&lt;/form&gt; \t&lt;/body&gt;&lt;/html&gt;\n","categories":["文档区"],"tags":["数据库"]},{"title":"桌面语音助手","url":"/2022/05/22/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2022-05-22_%E6%A1%8C%E9%9D%A2%E8%AF%AD%E9%9F%B3%E5%8A%A9%E6%89%8B/","content":" 功能需求:\n\n语音控制台灯\n语音控制…\n将控制信息显示在oled屏幕上\n\n 问题\n以前也做个类似的控制(小爱同学+esp8266+继电器) 但是这个缺点太大了. 不能免唤醒词 必须联网, 控制延迟也很大. 而且不能自定义回答\n 解决方案\n淘宝上买了一个语音控制的模块(SU-03T), 离线语音, 免唤醒, 响应时间很快. 完美符合我的要求. 在线编程自己生成sdk,和固件.\n 思维导图\n\n arduino代码\n#include &lt;Wire.h&gt; // 引入驱动OLED0.96所需的库#include &lt;Adafruit_GFX.h&gt;#include &lt;Adafruit_SSD1306.h&gt;#define SCREEN_WIDTH 128 // 设置OLED宽度,单位:像素#define SCREEN_HEIGHT 64 // 设置OLED高度,单位:像素#define OLED_RESET 4Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);#include &lt;SoftwareSerial.h&gt;  //软串口库SoftwareSerial mySerial(2,3); ////定义软串口，arduino的2号引脚作为RX，arduino的3号引脚作为TX，根据需要自行修改void setup()&#123;  Serial.begin(9600);  mySerial.begin(9600);  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);&#125;void loop()&#123;    DataJC();&#125;//------读取串口void DataJC()&#123;  if (mySerial.available() &gt; 0) //检测软串口是否有数据  &#123;    int val = 0;    val = mySerial.read();//读出串数据    Serial.println(val);  //从主串口打开出来    if (val == 161) &#123;      Serial.println(&quot;A1已开启&quot;);      A1_on();    &#125;    if (val == 162) &#123;      Serial.println(&quot;A1已关闭&quot;);      A1_off();    &#125;    if (val == 17) &#123;      Serial.println(&quot;响应&quot;);      Emoji_1();    &#125;  &#125;&#125;//表情:响应void Emoji_1()&#123;  display.clearDisplay();  display.setTextColor(WHITE);  display.setTextSize(4);  display.setCursor(45, 10);  display.print(&quot;Hi&quot;);  display.display();  delay(1000);  display.clearDisplay();  display.setTextColor(WHITE);  display.setTextSize(4);  display.setCursor(32, 10);  display.print(&quot;o o&quot;);  display.display();  delay(1000);&#125;//打开A1void A1_on()&#123;      display.clearDisplay();      display.setTextColor(WHITE);      display.setTextSize(2);      display.setCursor(0, 20);      display.print(&quot;A1 &gt;&gt; on&quot;);      display.display();      //delay(2000);&#125;//关闭A1void A1_off()&#123;      display.clearDisplay();      display.setTextColor(WHITE);      display.setTextSize(2);      display.setCursor(0, 20);      display.print(&quot;A1 &gt;&gt; off&quot;);      display.display();      //delay(2000);&#125;//向软串口输出数据void send_cmd(int cmd)&#123;  char mylist[9]=&#123;0xAA,0x55,0x01,0x01,0x00,0x00,0x00,0x55,0xAA&#125;;//设置发送列表  //改变数值  mylist[(int)(3)] = cmd;   mySerial.write(mylist[(int)(0)]);  mySerial.write(mylist[(int)(1)]);  mySerial.write(mylist[(int)(2)]);  mySerial.write(mylist[(int)(3)]);  mySerial.write(mylist[(int)(4)]);  mySerial.write(mylist[(int)(5)]);  mySerial.write(mylist[(int)(6)]);  mySerial.write(mylist[(int)(7)]);  mySerial.write(mylist[(int)(8)]);&#125;","categories":["实践项目"],"tags":["构思"]},{"title":"C#项目打包","url":"/2022/05/12/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-05-12_C_sharp%E6%89%93%E5%8C%85/","content":" 安装打包插件\n\n\n在Visual Studio的扩展中搜索installer然后选择并下载创建者为Microsoft的插件(安装量最多的那个).\n\n\n下载完成后会提示关闭当前项目,点击关闭.\n\n\n进行安装.\n\n\n 创建打包项目\n\n\n在Visual Studio启动界面(或者文件选项卡)新建一个Setup Project(如果找不到就搜索模板处输入SetUp).\n\n\n创建完项目后,会出现三个文件夹, 然后再Apelication Folder上右键添加需要打包的文件.\n\n\n添加完成后, 再给启动入口程序, 右键创建快捷方式, 然后拖动到, 剩下两个文件夹中(一个是桌面,一个是开始菜单).\n\n\n接着在属性窗口分别自定义图标.ICON.\n\n\n 生成打包文件\n\n\n右键解决方案下方项目, 点击生成.\n\n\n生成路径在项目文件夹中的Debug文件夹中(如果是Release就在Release文件夹中).\n\n\nDebug下会生成一个exe文件一个msi文件, 两个都可以用, 自行选择.\n\n\n","categories":["文档区"],"tags":["C_sharp"]},{"title":"markdown语法","url":"/2022/05/08/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-05-08_markdown%E8%AF%AD%E6%B3%95/","content":" 一级标题\n 二级标题\n 三级标题\n 四级标题\n 五级标题\n 六级标题\n# 一级标题## 二级标题### 三级标题....\t另一种写法:一级标题===二级标题---\n 段落语法\n空一行是换行\n空两行是换段\n注意换端的时候不要用空格或制表符\n 强调语法\n加粗\n**文字**\n斜体\n*文字*\n 引用语法\n\n引用文字…\n\n&gt; 引用文字\n\n123456\n\n嵌套引用\n12334\n\n\n&gt; 123456&gt;&gt; 嵌套引用&gt; 123456\n\n引用里面加列表\n\n1\n2\n3\n\n\n&gt; 引用里面加列表&gt; - 1&gt; - 2&gt; - 3\n 列表语法\n有序列表\n\n1\n2\n3\n\n1. 12. 23. 3\n无序列表\n\n1\n2\n3\n\n- 1- 2- 3或者+ 1+ 2+ 3或者* 1* 2* 3\n相互嵌套\n\n1\n\n2\n3\n\n\n4\n\n1. 1\t- 2\t- 32. 4\n","categories":["文档区"],"tags":[]},{"title":"机顶盒搭建FTP","url":"/2022/05/04/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2022-05-04_%E6%9C%BA%E9%A1%B6%E7%9B%92%E6%90%AD%E5%BB%BAFTP/","content":" 老旧机顶盒-创维E900S 刷机并搭建FTP服务\n 目录\n\n功能需求:\n设备列表:\n实现过程:\n访问方法:\n\n(ง •_ •)ง 谢谢阅读!\n\n 功能需求:\n\n电脑或手机端,能够随时连接到,外接在机顶盒上的移动硬盘或U盘.\n机顶盒能够正常看电视,并且开机自动启用FTP功能.\n\n 设备列表:\n\n机顶盒 (安装有当贝市场,至于怎么安装刷机包,我也是百度的)\n显示器\n硬盘,U盘\n电脑\n\n\n 实现过程:\n我使用的机顶盒是 创维E900S 芯片为S905L,其他机顶盒可以在当贝社区里面找ROM包\n\n 刷机包以及方法:\n创维E900-ST高安版-S905L芯片ROM固件https://www.znds.com/rom/741079.html\n当贝社区链接https://www.znds.com/rom/down/\n&quot;每步FTP&quot;软件下载地址http://www.meibu.com/soft/ftp.apk\n1.机顶盒刷机成功以后,打开当贝桌面,安装&quot;小白文件管理器app&quot; 使用里面的文件传输功能,上传&quot;每步FTP&quot;app,并安装. 也可以使用当贝自带的上传工具.\n\n2.外接一个U盘或硬盘\n3.打开&quot;小白资源管理器&quot;–文件管理–查看U盘,硬盘路径.\n\n4.打开&quot;每步FTP&quot;–设置–更改路径为硬盘路径.\n\n5.开启&quot;匿名登录&quot;,“保持设备唤醒”–返回\n6.开启FTP服务,成功以后会显示ftp地址\n\n\n**建议:**路由器端分配一个静态ip给机顶盒,不然ftp地址会变.\n**注释:**其实&quot;小白文件管理器&quot;自带FTP功能,但是不能开启自动启用FTP服务,且不能更改FTP映 射路径,所以使用&quot;每步FTP&quot;,网上找了好久才找到这个软件.\n 访问方法:\n 电脑端&gt;\n​    方法一:直接在资源管理器中输入FTP地址,例如&quot;ftp://192.168.10.10:2121/&quot;–回车即可访问.\n​    \n​    方法二:新建一个网络位置,按向导提示,输入FTP地址,下次可以直接在资源管理器中点击访问.\n​    \n 手机端&gt;\n​    下载es文件管理器等软件,里面有FTP服务,连接统一局域网,输入地址即可访问.\n","categories":["实践项目"],"tags":["旧物改造","FTP"]},{"title":"C#打开文件夹或文件","url":"/2022/05/04/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-05-04_C_sharp%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9%E6%88%96%E6%96%87%E4%BB%B6/","content":" 选择文件夹\n   private void btn_select(object sender, EventArgs e)   &#123;       //新建dialog对象       FolderBrowserDialog dialog = new FolderBrowserDialog();       //显示文字       dialog.Description = &quot;选择文件夹&quot;;       //默认路径       dialog.SelectedPath = @&quot;C:&quot;;       //判断文件夹路径是否为空       if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)       &#123;           if (string.IsNullOrEmpty(dialog.SelectedPath))           &#123;               //为空提醒               MessageBox.Show(this, &quot;文件夹路径不能为空&quot;, &quot;提示&quot;);               return;           &#125;           //命令行提示           Console.WriteLine(&quot;选择了：&quot; + dialog.SelectedPath);        &#125;       //保存路径string FilesPath = dialog.SelectedPath;   &#125;\n 选择文件\n   private string SelectPath()   &#123;       string Path = String.Empty;       OpenFileDialog dialog = new OpenFileDialog();       dialog.Multiselect = true;//该值确定是否可以选择多个文件       //提示文字       dialog.Title = &quot;请选择文件夹&quot;;       //设置选择文件类型（）显示的文件 | 过滤的文件       dialog.Filter = &quot;所有文件(*.*)|*.*&quot;;       if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)       &#123;           //变量赋值路径           Path = dialog.FileName;       &#125;//返回文件路径       return Path;   &#125;\n 打开文件或文件夹\n//填入文件或文件夹的路径。//默认System.Diagnostics.Process.Start(&quot;ExpLorer&quot;, &quot;C:\\\\window&quot;); //选择文件打开方式，并打开    // 目标文件路径 \tstring StartPath = Application.StartupPath + @&quot;\\scripts\\starthw.bat&quot;;    //（方法1） 记事本（特定程序）    string NotPath = System.Environment.SystemDirectory + &quot;\\\\notepad.exe&quot;;    System.Diagnostics.Process.Start(NotPath, StartPath);        //（方法2） 设置打开方式路径    string OpenPath = @&quot;C:\\Program Files (x86)\\sakura\\sakura.exe&quot;;    System.Diagnostics.Process.Start(OpenPath, StartPath);   \n","categories":["文档区"],"tags":["C_sharp"]},{"title":"C#创建并连接数据库以及增删查改","url":"/2022/05/04/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-05-04_C_sharp%E6%93%8D%E6%8E%A7Access%E6%95%B0%E6%8D%AE%E5%BA%93/","content":" 引入命名空间\nusing System.Data.OleDb;using System.IO;using ADOX;\n 动态创建数据库\n//数据库路径String filePath = &quot;C:\\\\Users\\\\18144\\\\OneDrive\\\\文档\\\\Access\\\\test2.accdb&quot;;if (!File.Exists(filePath))&#123;//数据库不存在// 创建Access数据库   ADOX.Catalog catalog = new ADOX.Catalog();   catalog.Create(&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source = C:\\\\Users\\\\18144\\\\OneDrive\\\\文档\\\\Access\\\\test2.accdb;Jet OLEDB:Database Password = 123456&quot;);   //Data Source = .\\\\Data\\\\Student.accdb;  当前位置创建       //释放Catalog对数据库文件的占用   System.Runtime.InteropServices.Marshal.FinalReleaseComObject(catalog.ActiveConnection);   System.Runtime.InteropServices.Marshal.FinalReleaseComObject(catalog);    return; &#125;else&#123;    //数据库已存在    MessageBox.Show(&quot;数据库文件已存在&quot;);         &#125;\n 创建数据表\n//合并连接字符串string DataLinkString = &quot;Provider = Microsoft.Jet.OLEDB.4.0;&quot;;DataLinkString += @&quot;Data Source = C:\\Users\\18144\\OneDrive\\文档\\Access\\test2.accdb;&quot;;DataLinkString += @&quot;Jet OLEDB:Database Password = 123456&quot;;//根据连接字符串，连接数据库OleDbConnection AD = new OleDbConnection(DataLinkString);//开启数据库AD.Open();//创建sql命令---删除表命令OleDbCommand sql_cmd1 = new OleDbCommand(&quot;drop table Info&quot;, AD);//执行sql命令sql_cmd1.ExecuteNonQuery();sql_cmd1.Dispose();//创建sql命令----创建表命令OleDbCommand sql_cmd2 = new OleDbCommand(&quot;create table Info (id char(15) primary key, name char(50))&quot;, AD);//执行sql命令sql_cmd2.ExecuteNonQuery();sql_cmd2.Dispose();//关闭数据库AD.Close();AD.Dispose();\n 执行sql命令\nprivate void RunSQL(string sql_cmd)&#123;    //void作用：运行sql代码//    try    &#123;        //合并连接字符串        string DataLinkString = &quot;Provider = Microsoft.Jet.OLEDB.4.0;&quot;;        DataLinkString += @&quot;Data Source = C:\\Users\\18144\\OneDrive\\文档\\Access\\test2.accdb;&quot;;        DataLinkString += @&quot;Jet OLEDB:Database Password = 123456&quot;;        //根据连接字符串，连接数据库        OleDbConnection conn = new OleDbConnection(DataLinkString);        //开启数据库        conn.Open();        //创建sql命令        OleDbCommand cmd = new OleDbCommand(sql_cmd, conn);        //执行sql命令        cmd.ExecuteNonQuery();        cmd.Dispose();        //关闭数据库        conn.Close();        conn.Dispose();    &#125;    catch (Exception e)    &#123;        MessageBox.Show(e.ToString(), &quot;提示&quot;);    &#125;&#125;\n 增加\n//sql增加命令string insert = &quot;insert into student values(&quot; + id + &quot;, &#x27;&quot; + name + &quot;&#x27;, &quot; + age + &quot;);&quot;;RunSQL(insert);\n 删除\n//sql删除命令string delete = &quot;delete from student where id = &quot; + id;RunSQL(delete);\n 修改\n//sql修改命令string update = &quot;update student set Name = &#x27;&quot; + name + &quot;&#x27;, Age = &quot; + age + &quot; where Id = &quot; + id;RunSQL(update);\n 查询\n         // 如果连接是关闭的，才进行打开          if (odc.State == ConnectionState.Closed) &#123;              conn.Open();          &#125;// sql操作语句          string select = &quot;select * from student where Age = &quot; + age;          // 创建设配器对象   【OleDbDataAdapter】          OleDbDataAdapter dbDataAdapter = new OleDbDataAdapter(select, cmd);          // 新建表对象          DataTable dataTable = new DataTable();          // 用设配器对象填充表对象          dbDataAdapter.Fill(dataTable);          // 将查找到的数据遍历输出          foreach (DataRow dr in dataTable.Rows) &#123;              Console.WriteLine(&quot;id = &#123;0&#125; name = &#123;1&#125; age = &#123;2&#125;&quot;, dr[0], dr[1], dr[2]);          &#125;\n","categories":["文档区"],"tags":["C_sharp","数据库"]},{"title":"js+html在网页上显示时间","url":"/2022/03/02/%E6%96%87%E6%A1%A3%E5%8C%BA/2022/2022-03-02_js+html%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4/","content":" 使用js 结合html 在网页上显示时间\n 文件列表\n\nindex.html\ntime.js\n\n html文件代码\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;获取当前时间&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script src=&quot;time.js&quot;&gt;&lt;/script&gt;\t\t&lt;div id=&quot;time&quot; &gt;&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;\n js文件代码\nwindow.onload=function()&#123;\twindow.requestAnimationFrame(getDate)&#125; function getDate()&#123;\twindow.setTimeout(function()&#123;\t\twindow.requestAnimationFrame(getDate)\t&#125;,1000/2)\tvar time=new Date();   \tvar year=time.getFullYear()  //年\tvar month=time.getMonth()+1;  //月\tvar day=time.getDay()    //日\tvar days=time.getDate() //日期\tvar hour=time.getHours()   //小时\tvar minute=time.getMinutes()  //分钟\tvar second=time.getSeconds()   //秒\tif(month&lt;10) month=&quot;0&quot;+month\tif(days&lt;10) days=&quot;0&quot;+days\tif(hour&lt;10) hour=&quot;0&quot;+hour\tif(minute&lt;10) minute=&quot;0&quot;+minute\tif(second&lt;10) second=&quot;0&quot;+second\tvar weekshow=new Array(&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;)\tvar HT=document.getElementById(&quot;time&quot;)   //设置html文件,访问ID\tvar timeshow1=&quot;日期:  &quot;+year+&quot;-&quot;+month+&quot;-&quot;+days+&quot;  &quot;+&quot;星期&quot;+weekshow[day]\tvar timeshow2=&quot;时间:&quot;+hour+&quot; : &quot;+minute+&quot; :&quot;+second \tHT.innerHTML= timeshow1//显示日期\t//HT.innerHTML= timeshow2//显示时间,自行更改 &#125;\n\n","categories":["文档区"],"tags":["js","html"]},{"title":"51单片机连接蓝牙模块","url":"/2021/06/04/%E6%96%87%E6%A1%A3%E5%8C%BA/2021/2021-06-04_51%E5%8D%95%E7%89%87%E6%9C%BA%E8%BF%9E%E6%8E%A5%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97/","content":" 51单片机连接蓝牙模块（发送多个数据）\n 代码\n#include&lt;regx52.h&gt;#include&lt;intrins.h&gt;#include&lt;string.h&gt; #define chartonumber(x) (x + &#x27;0&#x27;)//装换INT到char里面 sbit Buzzer = P1^3;unsigned int hh;unsigned char code DateTable[]=&#123;&quot;12345&quot;&#125;; //-----?? ??-----//void Delay(unsigned int xms)\t\t//@11.0592MHz&#123;\tunsigned char i, j;    \twhile(xms)&#123;\t\t_nop_();\t\ti = 2;\t\tj = 199;\t\tdo\t\t&#123;\t\twhile (--j);\t\t &#125; while (--i);\t\txms--;\t&#125;&#125;  void Delay1us(unsigned int mms)\t\t//@11.0592MHz&#123;\twhile(mms)&#123;\t_nop_();\t_nop_();\t_nop_();\tmms--;  &#125;\t\t&#125;//----------------------//unsigned char SenData;           //发送 数据char Flag;                       //标准位unsigned char ReData;            //接收数据 //函数声明 void usart_init();                //串口中断初始化 void send_data(unsigned char a);  //串口数据发送 //--------------------------- //----------串口中断初始化函数-----------------      void usart_init() &#123;    SCON = 0x50;                  //REN=1允许串行接受状态，串口工作模式1                          TMOD = 0x20;                  //定时器工作方式2                        PCON = 0x00;                                                              TH1  = 0xFD;                  //波特率9600，数据为8，停止位1 (11.0592M)    TL1  = 0xFD;                                                               ES   = 1;                     //开串口中断                      EA   = 1;                     //开总中断             TR1  = 1;                     //启动定时器&#125; //--------------------------- //---------串口数据发送------------------- void send_data(unsigned char a)&#123;      SBUF = a;                      //SUBF接受/发送缓冲器    while(0 == TI);                //等待发送完毕，再执行    TI=0;                         //手动清0&#125; void send_data_cc( int a)&#123;    char bai,shi,ge,fen;  int shu;\tshu=a;   \t//\tbai=shu/1000;//\tshi=shu/100%10;//\tge=shu/10%10;//\tfen=shu%10;\t\tbai = chartonumber(shu/1000);\tshi = chartonumber(shu/100%10);\tge = chartonumber(shu/10%10);\tfen = chartonumber(shu%10);\tSBUF = bai;//SUBF接受/发送缓冲器\twhile(!TI); //等待发送完毕，再执行\tTI=0;      //手动清0\tSBUF = shi;\twhile(!TI);\tTI=0;\tSBUF = ge;\twhile(!TI);\tTI=0;\tSBUF = fen;\twhile(!TI);\tTI=0;\t\t\t\t\t                        &#125;//---------------------------//---------------------------void ser_int (void) interrupt 4 using 1 &#123;    if(1 == RI)                    //RI接受中断标志    &#123;        RI = 0;                    //清除RI接受中断标志        ReData = SBUF;             //SUBF接受/发送缓冲器        Flag=1;                     //标志位置1表示有新数据进来    &#125;&#125; //---------------------------//---------------------------unsigned char i; void main()&#123;        usart_init();       //串口中断初始化     while(1)    &#123;                 if (Flag==1)                      &#123;\t            EA=0;                  //判断是否有数据进来            send_data_cc(280); \t\t\t\t\t\tDelay(10);\t\t\t\t\t\tP1=0xFF; \t\t\t\t\t\tFlag=0;                  //数据处理完毕将标志位置0，表示没有新数据要处理\t\t\t\t\t\tEA=1;                   //打开总中断，允许接收新数据\t\t\t\t&#125;     &#125;        &#125;","categories":["文档区"],"tags":["单片机"]}]