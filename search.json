[{"title":"博客上传命令行测试","url":"/2023/08/02/%E6%B5%8B%E8%AF%95%E5%8C%BA/2023-08-02_%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B5%8B%E8%AF%95/","content":" 批处理BAT命令行\n@echo offchcp 65001echo &quot;▬▬▬▬▬▬▬▬▬▬▬▬▬▶ 已切换中文编码&quot;echo &quot;▬▬▬▬▬▬▬▬▬▬▬▬▬▶ 清除缓存已禁用！如果博客样式出现问题，请重新开启&quot;cd /d  D:\\UerLinkBlogtitle HexoGocd%call hexo clean%echo &quot;▬▬▬▬▬▬▬▬▬▬▬▬▬▶ 博客开始重新生成:&quot;call hexo gecho &quot;▬▬▬▬▬▬▬▬▬▬▬▬▬▶ 博客开始上传GitHub:&quot;call hexo decho &quot;▬▬▬▬▬▬▬▬▬▬▬▬▬▶ 博客预览服务启动:&quot;call hexo spause\n","categories":["测试区"],"tags":[]},{"title":"mod开发笔记","url":"/2023/08/02/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-08-02_mod%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","content":" 星露谷物语mod开发\n 每天早晨打印一条消息\n/// &lt;summary&gt;模组的主要入口点。&lt;/summary&gt;public class ModEntry : Mod&#123;    /**********    ** 公共方法    *********/    /// &lt;summary&gt;模组入口点，加载模组后自动调用&lt;/summary&gt;    /// &lt;param name=&quot;helper&quot;&gt;提供用于编写模组的简化API&lt;/param&gt;    public override void Entry(IModHelper helper)    &#123;        // 事件 += 方法        helper.Events.GameLoop.DayStarted += this.OnDayStarted;    &#125;        /**********    ** 私有方法    *********/    /// &lt;summary&gt;在新的一天开始后调用的方法&lt;/summary&gt;    /// &lt;param name=&quot;sender&quot;&gt;事件对象&lt;/param&gt;    /// &lt;param name=&quot;e&quot;&gt;事件参数&lt;/param&gt;    private void OnDayStarted(object sender, DayStartedEventArgs e)    &#123;       this.Monitor.Log($&quot;新的一天到来了！&#123;Game1.player.Name&#125; 享受你的新一天吧&quot;, LogLevel.Debug);    &#125;&#125;","categories":["文档区"],"tags":["mod","game"]},{"title":"博客上传常见问题","url":"/2023/08/02/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/2023-08-02_%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","content":" 解决上传时提示warning: LF will be replaced by CRLF in的方法\n 原因\n不同操作系统行尾结束符不一样：\nUinx/Linux --- \\n(LF); windows --- \\r\\n(CRLF)\n 方法\n在git上配置core.autocrlf属性为false，默认为trun\n git config --get core.autocrlf   //查看命令git config --global core.autocrlf false    //修改命令\n","categories":["踩坑记录"],"tags":["blog"]},{"title":"TP4056芯片充电电路","url":"/2023/08/01/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/2023-08-01_TP4056%E8%8A%AF%E7%89%87%E5%85%85%E7%94%B5%E7%94%B5%E8%B7%AF/","content":" 使用TP4056芯片实现对锂电池进行充电\n 芯片说明\n\n锂电池管理芯片tp4056中文资料及应用电路图汇总 - IC应用电路图 - 电子发烧友网 (elecfans.com)\n\nTP4056是一款完整的单节锂离子电池采用恒定电流/恒定电压线性充电器。其底部带有散热片的SOP8封装与较少的外部元件数目使得TP4056成为便携式应用的理想选择。TP4056可以适合USB电源和适配器电源工作。由于采用了内部PMOSFET架构，加上防倒充电路，所以不需要外部隔离二极管。热反馈可对充电电流进行自动调节，以便在大功率操作或高环境温度条件下对芯片温度加以限制。充电电压固定于4.2V，而充电电流可通过一个电阻器进行外部设置。当充电电流在达到最终浮充电压之后降至设定值1/10时，TP4056将自动终止充电循环。\n 引脚\nVCC：电压输入\nGND：接地\nCE：芯片使能输入端。高电平有效\nBAT：电池正极（+）连接端\nTEMP：电池温度检测输入端\nPROG：恒流充电电流设置端\nCHRG：充电状态指示端，输出\nSTDBY：充电完成指示端，输出\n 限流电阻阻值表\n\n锂电池充电IC-TP4056电路设计详解_tp4056充电电路图_董程森的博客-CSDN博客\n\n通过设置R3(下图中)电阻，阻值大小，更改BAT端输出电流大小\n 原理图\n\n","categories":["硬件设计"],"tags":["PCB","芯片"]},{"title":"StableDiffusion绘制二维码","url":"/2023/07/14/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-07-14_StableDiffusion%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E7%A0%81/","content":" 效果图\n\n 模型\n需要在controlnet中使用该模型\nmonster-labs/control_v1p_sd15_qrcode_monster at main (huggingface.co)\n","categories":["文档区"],"tags":["AI","画画"]},{"title":"stableDiffusion安装roop插件","url":"/2023/07/14/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/2023-07-14_stableDiffusion%E5%AE%89%E8%A3%85roop%E6%8F%92%E4%BB%B6/","content":" stableDiffusion安装roop插件折腾的过程\n 过程\n秋叶版本Stablediffusion的Roop插件的安装_哔哩哔哩_bilibili\n照着这个视频安装完成后，开始运行出现错误\n 错误\nStable Diffusion入门（十三）：深度换脸 | roop - 知乎 (zhihu.com)\n也就是这个教程，第二个错误，下载包不完整\n踩坑：下载buffalo_l.zip以后要解压，把里面的文件放出来到buffalo_l文件夹，要不然一直下载，而且下载速度极慢\n","categories":["文档区"],"tags":["AI","画画","踩坑记录"]},{"title":"本地部署Chat-RWKV-LM","url":"/2023/07/09/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-07-09_%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Chat-RWKV-LM/","content":" 本地离线使用，类Chat GPT工具Chat-RWKV-LM\n\n无需额外付费，使用GPU或CPU进行计算得出结果\n\n RWKV-LM官方GitHub地址：\nhttps://github.com/BlinkDL/RWKV-LM\n RWKV-Runner 启动器GitHub地址：\nhttps://github.com/josStorer/RWKV-Runner\n 部署\n\n下载好启动器，把exe放在一个空文件夹\n运行exe，并随便点击一个模型运行，提示需要python环境，下载即可\n\n 参考视频\n【RWKV-Runner发布并开源，可商用的大语言模型，一键启动管理，2-32G显存适配，API兼容，一切前端皆可用】\nhttps://www.bilibili.com/video/BV1hM4y1v76R/?share_source=copy_web&amp;vd_source=17fc3f0d3cf17f45237a57cc5ba97e0e\n 注意事项\n\n每个模型的所呈现的效果都不用，选择最适合的模型\n\n 模型名称\n例如：GPU-2G-3B-world\n使用GPU计算，显存需要2G，模型参数3B大小，（一般world表示最新的模型）\n","categories":["文档区"],"tags":["AI"]},{"title":"调用非官方GPT的api","url":"/2023/07/09/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-07-09_%E8%B0%83%E7%94%A8%E9%9D%9E%E5%AE%98%E6%96%B9GPT%E7%9A%84api/","content":" 调用api2gpt.com网站提供的镜像GPT的api\n\n因为OPEN AI 的GPT在只能在环大陆地区使用，注册账号并充值很麻烦不稳定，有一定门槛。调用api也需要魔法环境，偶然间发现一个GPTapi提供网站，使用了一下，感觉不错，费用比OPENAI相对便宜调用API时不需要魔法。\n\n 网址：\nhttps://console.api2gpt.com/\n 使用方法\n把openai的接口地址换成https://api.api2gpt.com，然后把Key填入就可以了。其实就是和访问OPEN AI 的接口一样。\n 吐槽：\n我的OPEN AI 账号，7月1日到期了，想充值都没办法充！\n","categories":["文档区"],"tags":["api","AI","GPT"]},{"title":"arduino下载到esp8266报错","url":"/2023/06/13/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/2023-06-13_arduino%E4%B8%8B%E8%BD%BD%E5%88%B0esp8266%E6%8A%A5%E9%94%99/","content":" 错误日志：\nA fatal esptool.py error occurred: Cannot configure port, something went wrong. Original message: PermissionError(13, &#x27;����ϵͳ�ϵ��豸û�з������á�&#x27;, None, 31)\n 解决办法：\n重新安装ch340驱动，（注意需要安装老版本的ch340驱动）\n下载链接：CH341SER.zip - Electropeak\n","categories":["踩坑记录"],"tags":["踩坑记录","arduino"]},{"title":"Stable Diffusion模型-AI画画","url":"/2023/06/09/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-06-09_Stable%20Diffusion%E6%A8%A1%E5%9E%8B-AI%E7%94%BB%E7%94%BB/","content":" 本地电脑安装 Stable Diffusion-AI绘画软件\n[\n 下载整合包\n首先下载“电子菩萨” – 秋葉aaaki  的 整合包\n秋葉aaaki的个人空间_哔哩哔哩_bilibili\n【AI绘画】Stable Diffusion整合包v4发布！全新加速 解压即用 防爆显存 三分钟入门AI绘画 ☆可更新 ☆训练 ☆汉化_哔哩哔哩_bilibili\n 踩坑的问题\n下载下来的整合包.zip 一直解压错误，后来更换下载器重新下载就可以了\n 新知识\n 1.更换绘画模型\n炼丹阁\n\n国内的模型下载网站\n\nHugging Face\n\n国外的模型下载网站\n我也没太弄懂\n\n 2.LoRA模型\nLoRA相当于对图像进行风格化修改\n","categories":["文档区"],"tags":["AI","画画"]},{"title":"webmin工具的安装","url":"/2023/05/23/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-05-23_webmin%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85/","content":" 通过webmin工具远程管理配置服务器\n 安装配置面板 WebMin\n 使用deb包进行安装\n下载路径：http://sourceforge.net/projects/webadmin/files/webmin/\nsudo dpkg -i webmin_1.981_all.deb\n处理依赖关系\nsudo apt install -f\n 启动服务\n开启端口10000\nsudo ufw allow 10000\n重启\nreboot\n登录\nhttps：//服务器 ip：10000","categories":["文档区"],"tags":["Linux"]},{"title":"Ubuntu安装nginx，部署网站","url":"/2023/04/26/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-04-26_Ubuntu%E5%AE%89%E8%A3%85nginx%EF%BC%8C%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/","content":" Ubuntu系统中安装nginx服务，实现部署网站\n 切换至root用户,并安装nginx\nNginx 在默认的 Ubuntu 源仓库中可用\nsudo apt updatesudo su rootapt-get install nginx\n 查看nginx是否安装成功\nnginx -v\n 运行控制\n 启动nginx\nservice nginx start\n 各种重启\nservice nginx restartsudo systemctl restart nginxnginx -s reload\n 停止\nservice nginx stop\n nginx文件安装完成之后的文件位置：\n/usr/sbin/nginx：主程序\n/etc/nginx：存放配置文件\n/usr/share/nginx：存放静态文件\n/var/log/nginx：存放日志\n 配置网站\n在/etc/nginx/conf.d目录中新建后缀名为 .conf 的空白文件 test.conf\n写入配置表\nserver &#123;    listen       80;    server_name  example.com;    #开启openai接口的gzip压缩，大量重复文本的压缩率高，节省服务端流量    gzip  on;    gzip_min_length 1k;    gzip_types text/event-stream;    #如需部署在网站子路径，如&quot;example.com/chatgpt&quot;，配置如下    #location ^~ /chatgpt/v1 &#123;    location ^~ /v1 &#123;        proxy_pass https://api.openai.com/v1;        proxy_set_header Host api.openai.com;        proxy_ssl_name api.openai.com;        proxy_ssl_server_name on;        #注意Bearer 后改为正确的token。如需网页设置自定义API key使用，则注释掉下一行        proxy_set_header  Authorization &quot;Bearer sk-your-token&quot;;        proxy_pass_header Authorization;        #流式传输，不关闭buffering缓存会卡顿卡死，必须配置！！！        proxy_buffering off;    &#125;    #与上面反代接口的路径保持一致    #location /chatgpt &#123;    location / &#123;        alias /usr/share/nginx/html/;        index index.html;    &#125;&#125;\n检查配置是否生效\nnginx -t\n 配置ssl证书\n参考教程链接：Nginx操作 | Nginx配置SSL证书 - 知乎 (zhihu.com)\n配置完以后要重启\nsudo service nginx restart\n注意ssl认证文件的路径要正确\nserver &#123;    listen 443;    # 你的域名    server_name xxx.cn;    ssl on;    # 你网站的根目录    root /usr/share/nginx/html;     index index.html index.htm;    ssl_certificate  cert/hk.uerlink.cn.pem;    ssl_certificate_key cert/hk.uerlink.cn.key;    ssl_session_timeout 5m;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_prefer_server_ciphers on;&#125;","categories":["文档区"],"tags":[]},{"title":"C++对一元二次求解","url":"/2023/04/18/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-04-18_C++%E5%AF%B9%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%B1%82%E8%A7%A3/","content":" 求解\n\n2023-04-18 保存备份\n\n#include&lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;cmath&gt;using namespace std;int operation_data(int n,int e,int d)&#123;    //定义文件对象    ofstream outFile;    //题目数学公式转换    //n = p * q;    //e * d = (p-1)*(q-1)+1    //-(q*q) + [n+2-(e*d)]*q - n = 0    int a = -1;    double b = (n + 2 - (e * d));    double c = -n;    //求解    double q = (-b + sqrt(b*b - 4*a*c))/2*a;    double p = (-b - sqrt(b*b - 4*a*c))/2*a;    //打开文件    outFile.open(&quot;decode.out&quot;,ios::app);    //判断q和p是否为整数，如果为整数就保存，否则就保存&quot;NO&quot;    //floor() 函数返回不大于给定实数的最大整数    if(q == floor(q) &amp;&amp; p == floor(p))&#123;        cout&lt;&lt;q&lt;&lt;&quot; &quot;&lt;&lt;p&lt;&lt;endl;        outFile &lt;&lt; q &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot;\\n&quot;;    &#125;else&#123;        cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;        outFile &lt;&lt; &quot;NO&quot; &lt;&lt;&quot;\\n&quot;;    &#125;    outFile.close();    return 0;&#125;int main() &#123;    //定义文件对象    ifstream inFile;    ofstream outFile;    string line;    int Column=0;    int Row=0;    int arr[3];    //清空decode.out文件的内容    outFile.open(&quot;decode.out&quot;,ios::trunc);    outFile.close();    //读取文件    inFile.open(&quot;decode.in&quot;, ios::in);    if (!inFile.is_open())    &#123;        cout &lt;&lt; &quot;读取文件失败&quot; &lt;&lt; endl;        return 0;    &#125;else&#123;        //getline可以文件文件内容保存每行的数据到line        while (getline(inFile,line))        &#123;            //使用stringstream            stringstream ss(line);            //读取当前行每列的内容，并保存到数组            Column=0;            while (ss &gt;&gt; arr[Column]) &#123;                Column++;            &#125;            //去除读取文件时开头的0，我也不知道为啥会有个0            if(Row!=0)&#123;                //执行数据计算函数                operation_data(arr[0],arr[1],arr[2]);            &#125;            Row++;        &#125;    &#125;    return 0;&#125;","categories":["文档区"],"tags":[]},{"title":"c++读取和保存数据到文件","url":"/2023/04/18/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-04-18_c++%E8%AF%BB%E5%8F%96%E5%92%8C%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E5%88%B0%E6%96%87%E4%BB%B6/","content":" c++进行读取和保存\n使用fstream和sstream\n#include&lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;using namespace std;int main() &#123;//------------读取文件----------    //定义文件对象    ifstream inFile;    ofstream outFile;    string line;    int arr[3];    inFile.open(&quot;decode.in&quot;, ios::in);    if (!inFile.is_open())    &#123;        cout &lt;&lt; &quot;读取文件失败&quot; &lt;&lt; endl;        return 0;    &#125;else&#123;        //getline可以文件文件内容保存每行的数据到line        while (getline(inFile,line))        &#123;            //使用stringstream            stringstream ss(line);            //读取当前行每列的内容，并保存到数组            int Column=0;            while (ss &gt;&gt; arr[Column]) &#123;                Column++;            &#125;        &#125;    &#125;// --------保存文件----------    ofstream outFile;    //打开文件,ios::app是追加数据    outFile.open(&quot;decode.out&quot;,ios::app);    //存放数据    outFile &lt;&lt;&quot;A&quot;&lt;&lt;&quot; &quot;&lt;&lt;&quot;B&quot;&lt;&lt; &quot;\\n&quot;;    outFile.close();    //清空decode.out文件的内容,ios::trunc    outFile.open(&quot;decode.out&quot;,ios::trunc);    outFile.close();    return 0;&#125;","categories":["文档区"],"tags":[]},{"title":"Linux下搭建frask框架","url":"/2023/04/15/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-04-15_Linux%E4%B8%8B%E6%90%AD%E5%BB%BAfrask%E6%A1%86%E6%9E%B6/","content":" 安装Flask\n 安装python和虚拟环境(venv)\nsudo apt install python3sudo apt install python3-pipsudo apt install python3-venv\n 创建虚拟环境\n\n新建一个空白文件夹，并进入\n\nmkdir flask_app &amp;&amp; cd flask_app\n\n创建一个名为venv的虚拟环境\n\npython3 -m venv venv\n 进入/退出 虚拟环境\n\n进入\n\nsource venv/bin/activate\n\n退出\n\ndeactivate\n 下载Flask\n\n进入虚拟环境，使用pip工具安装flask\n\npip install Flask\n\n验证安装是否成功\n\npython -m flask --version\n 测试\n\n创建一个最小应用程序，下面内容写入名为 main.py 文件\n\nfrom flask import Flask app = Flask(__name__) @app.route(&#x27;/&#x27;) def hello_world(): \treturn &#x27;Hello World!&#x27;\n\n设置FLASK_APP环境变量\n\nexport FLASK_APP=main.py\n\n运行应用\n\nflask run\n\n访问生成的网站，测试完成\n\n","categories":["文档区"],"tags":["python","框架","frask","Linux"]},{"title":"python接入chatgpt的api","url":"/2023/04/15/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-04-15_python%E6%8E%A5%E5%85%A5chatgpt%E7%9A%84api/","content":" 非流式响应\nimport openaiopenai.api_key = &quot;这里放入你的API Key，注意要保留双引号&quot; completion = openai.ChatCompletion.create(  model=&quot;gpt-3.5-turbo&quot;,   messages=[&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;知乎是什么？&quot;&#125;])# 将得到的openai对象转换成python字典  data_json = completion.to_dict()print(data_json)\n 可运行代码\nimport openaiopenai.api_key = &quot;sk&quot;question: str = input(&quot;问题: &quot;)completion = openai.ChatCompletion.create(  model=&quot;gpt-3.5-turbo&quot;,  messages=[&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: question&#125;])# 将得到的openai对象转换成python字典data_json = completion.to_dict()data_json = data_json[&#x27;choices&#x27;][0][&#x27;message&#x27;][&#x27;content&#x27;]print(&quot;AI: &quot; + data_json)\n 流式响应\nimport openaiopenai.api_key = &quot;这里放入你的API Key，注意要保留双引号&quot; completion = openai.ChatCompletion.create(  model=&quot;gpt-3.5-turbo&quot;,   messages=[&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;知乎是什么？&quot;&#125;])# 将得到的openai对象转换成python字典  data_json = completion.to_dict()print(data_json)\n 可运行代码\nimport openai    openai.api_key = &quot;sk-AmHHPxId&quot;  question: str = input(&quot;问题: &quot;)  completion = openai.ChatCompletion.create(  model=&quot;gpt-3.5-turbo&quot;,  stream=True,  messages=[&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: question&#125;]  )    collected_events = [] # 响应接收区  stream_result = &#x27;&#x27; # 保存流式输出的总结果  for event in completion:  collected_events.append(event) # 保存事件响应  data_dict = event.to_dict() # 转换响应为字典  data_openai_object = data_dict[&#x27;choices&#x27;][0] # 获取choices的值  data_json = data_openai_object.to_dict() # 转换openai_object为字典  data_openai_object = data_json[&#x27;delta&#x27;] # 获取delta的值  finish_reason = data_json[&#x27;finish_reason&#x27;] # 获取finish的值,用于判断是否传输结束  data_json = data_openai_object.to_dict() # 转换openai_object为字典  segmental_result = data_json.get(&#x27;content&#x27;, &quot;null&quot;) # 获取content的值，如果没有就返回null    if(segmental_result != &quot;null&quot;): # 判断“分段结果”内是否有内容，有就输出  print(segmental_result, end=&quot;&quot;) # 输出“分段结果“的内容  else:  if (finish_reason == &quot;stop&quot;):  print(&quot;\\n 结束对话&quot;)    \n","categories":["文档区"],"tags":["AI","GPT"]},{"title":"python解析json文件","url":"/2023/04/15/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-04-15_python%E8%A7%A3%E6%9E%90json%E6%96%87%E4%BB%B6/","content":" 导入库\nimport json\n参考学习链接：使用Python读取和解析JSON数据教程 - 知乎 (zhihu.com)\n 解析json\n读取json文件并将json解析为python字典或列表（取决于json文件的内容）\n# 读取json文件并将json解析为python字典data_json = json.load(open(&#x27;txt.json&#x27;))````#### 实用操作操作[字典和列表](字典和列表.md)##### strip() 函数```pythonstr = &quot;00000003210Runoob01230000000&quot;; print str.strip( &#x27;0&#x27; ); # 去除首尾字符 0 str2 = &quot; Runoob &quot;; # 去除首尾空格 print str2.strip();\n 获取网址返回的json数据\nimport json  import requests  def json_out():  url = requests.get(&quot;http://127.0.0.1:5000/&quot;)  data = json.loads(url.text)  print(data)    if __name__ == &#x27;__main__&#x27;:  json_out()\n 构造json\n```textimport jsonlanguages = [&quot;English&quot;,&quot;French&quot;]country = &#123;       &quot;name&quot;: &quot;Canada&quot;,       &quot;population&quot;: 37742154,       &quot;languages&quot;: languages,       &quot;president&quot;: None,&#125;country_string = json.dumps(country)print(country_string)\n\n","categories":["文档区"],"tags":["python","json"]},{"title":"服务器Linux配置ssh免登录","url":"/2023/04/14/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-04-14_%E6%9C%8D%E5%8A%A1%E5%99%A8Linux%E9%85%8D%E7%BD%AEssh%E5%85%8D%E7%99%BB%E5%BD%95/","content":" ssh配置免登录\n服务器：Server\n客户端：Client\n 第一步\n在客户端通过 ssh-keygen 命令生成密钥\nssh-keygen -t rsa\n执行完以后直接按回车键 3 次，会在当前用户根目录生成一个 .ssh 文件夹\n 第二步\n拷贝密钥到服务器，有三种方法\n\nssh-copy-id 命令\nscp 命令\n手工复制\n\n这次我们采用“手工复制”的方法，先使用cat命令查看密钥，并复制\ncat ~/.ssh/id_rsa.pub\n 第三步\n然后再登录服务器，将密钥追加的到文件 ~/.ssh/authorized_keys 中去，注意是追加\n最后不出意外就搞定了！\n","categories":["文档区"],"tags":[]},{"title":"文档标签","url":"/2023/04/10/%E6%B5%8B%E8%AF%95%E5%8C%BA/2023-04-10_%E6%96%87%E6%A1%A3%E6%A0%87%E7%AD%BE/","content":" 各种颜色的标签\n 格式\n&#123;% note style %&#125;内容&#123;% endnote %&#125;\n style\nprimary\nsuccess\ninfo\nwarning\ndanger\n","categories":["测试区"],"tags":[]},{"title":"视频嵌入测试","url":"/2023/04/10/%E6%B5%8B%E8%AF%95%E5%8C%BA/2023-04-10_%E8%A7%86%E9%A2%91%E5%B5%8C%E5%85%A5%E6%B5%8B%E8%AF%95/","content":" hexo框架下博客页面嵌入视频\n 代码\n&lt;div&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=853187459&amp;bvid=BV1AL4y1L7cg&amp;cid=577298153&amp;page=1&amp;high_quality=1&amp;danmaku=0&quot; allowfullscreen=&quot;allowfullscreen&quot; width=&quot;100%&quot; height=&quot;450&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; framespacing=&quot;0&quot; sandbox=&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;\n 视频\n\n因网络原因可能导致视频加载缓慢\n\n 视频1\n\n\n\n 视频2\n\n\n\n","categories":["测试区"],"tags":[]},{"title":"Linux软件安装与卸载","url":"/2023/04/10/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-04-10_Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/","content":" 软件包分类\nLinux 安装包主要有两种：\nUbuntu 和 Debian 使用的是 .deb 格式的安装包\nred hat centos 使用的是 .rpm 格式的安装包\n 软件包管理器\nUbuntu 和 Debian 使用的管理器是 apt\nred hat centos 使用的管理器是 yum\nUbuntu 现在还推荐使用一种新的管理器 snap\n atp命令行\n命令：apt update   —获取最新软件包列表, 同步sources.list\n命令：apt upgrate  —更新当前系统所有安装的软件包和相关依赖\n命令：apt install  —下载并安装软件包\n命令：apt remove  —卸载软件包\n命令：apt purge —卸载软件包，并删除配置文件\n命令：apt list  —列出包含条件的软件包\n命令：apt show  —显示软件包详情信息\n命令：apt search  —搜索应用程序\n 换源\nvi /etc/apt/sources.list\n dpkg包\n\ndpkg本身是一个底层工具，而APT则是位于上层的工具\n\n 安装\n命令：dpkg -i 软件包名  —安装Deb软件包\n 卸载\n命令：dpkg -r 软件包名  —卸载Deb软件包\n命令：dpkg -p 软件包名  —卸载Deb软件包，并删除配置信息\n 其他\n命令：sudo apt --fix-broken install   —自动完成依赖关系的处理\n命令：dpkg -l  软件包名  —查询指定软件包\n命令：dpkg -s 软件包名   —查询指定软件包的详细说明\n Snap包\n\n是针对Linux和物联网设计的，类似一个容器，完全独立与系统\n\n 安装\n命令：snap install 软件包名  --安装Snap软件包\n命令：snap refresh 软件包名  --手动更新软件Snap软件包\n 其他\n命令：snap list  —列出采用Snap包的应用软件\n命令：snap find 软件包名  —搜索snap软件包\n命令：snap info 软件报名  —查询指定软件包的详情信息\n 解压包\n以下是一些常见的Linux解压命令：\n命令：tar -xvf filename.tar    —解压tar文件\n命令：tar -xzvf filename.tar.gz   —解压gzip格式的tar文件\n命令：tar -xjvf filename.tar.bz2  ----解压bzip2格式的tar文件\n命令：unzip filename.zip    ----解压zip文件\n命令：unrar x filename.rar    ----解压rar文件\n 源代码安装\n 编译\n命令：sudo make   —使用命令 make 在当前文件夹进行编译\n\nmake 会依据 Makefile 文件的设置，将源代码编译成可执行的二进\n制文件\n\n 安装\n命令：sudo make install   —安装makefile中设置，安装到指定文件夹\n\n多数源码安装包会提供一个 configure 文件，用来自动检测操作环\n境，并可生 成 Makefile 文件\n在当前文件夹执行此命令 ./configure\n\n 卸载\n命令：sudo make uninstall  —卸载\n命令：sudo make clean  —卸载\n checkinstall 命令\n\ncheckinstall 是一个能将源代码制作成安装包的程序，并自动安装\n\nsudo apt install checkinstall\n命令：sudo checkinstall  —安装并生成deb安装包\n","categories":["文档区"],"tags":[]},{"title":"Linux翻译api接入终端","url":"/2023/03/27/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-03-27_Linux%E7%BF%BB%E8%AF%91api%E6%8E%A5%E5%85%A5%E7%BB%88%E7%AB%AF/","content":" 目录结构\n\nfy.php\nfy.sh#\n\n github地址\nhttps://github.com/UerLink/Terminal-small-tools\n 请安装php环境\nsudo apt-get install php\n fy.php\n\napi使用的是https://api.vvhan.com/fanyi.html\n\n&lt;?phpheader(&quot;Content-Type:text/json;charset=UTF-8&quot;);$info = $argv[1];$json_string = file_get_contents(&quot;https://api.vvhan.com/api/fy?text=&quot; . $info);$decoded_data = json_decode($json_string, true);$fanyi = $decoded_data[&#x27;data&#x27;][&#x27;fanyi&#x27;];echo &quot;\\033[34m⇢\\033[0m  $fanyi  \\033[34m⇠ 翻译结果\\033[0m&quot;;?&gt;\n fy.sh\n#!/bin/bashif [ -n &quot;$1&quot; ]then \tinfo=$1\tphp fy.php &quot;$info&quot;else\techo -e &quot;\\033[32m[提示]\\033[0m \\033[34m命令格式：\\033[0m fyy 要翻译的内容&quot;fi\n 使用方式\n 方式一\n终端中输入  ./fy.sh 要翻译的内容\n 方式二\n\n把fy.sh中的php fy.php “$info” 的路径改成绝对路径\n添加权限\n\nchown  root:root fy.sh\n\n再移动fy.sh文件\n\nsudo mv fy.sh /usr/bin/fy\n\n之后就可以直接在终端中输入 fy 内容\n\n","categories":["文档区"],"tags":["api"]},{"title":"ChatGPT镜像网站","url":"/2023/03/25/%E6%B5%8B%E8%AF%95%E5%8C%BA/2023-03-25_ChatGPT%E9%95%9C%E5%83%8F%E7%BD%91%E7%AB%99/","content":" 简单介绍：ChatGPT为OPENAI开发的人工智能，是一个非常好用的工具\n最后更新时间: 2023-08-02，注意在这时间之后，下列网站可能已经失效\n 官网\n\n需要魔法，才能访问\n\nhttps://chat.openai.com/chat\nhttps://platform.openai.com/account/api-keys\n 镜像api网站（推荐）\nApi2Gpt | Api2Gpt（可以无需魔法使用chatgpt的api接口，目前我正在使用的也是这个，我的openai账号到期了，懒得搞了）\n 免登录，速度还行\n\n有几个可以用api-key，不填也基本上可以用\n\nhttps://chatmindai.cn（每天可以免费使用几次GPT4）\nhttps://chat.gpt.bz/gpt/（已失效）\nhttps://www.ourfpv.com/chat/（已失效）\nhttps://chat.cutecloud.link/（已失效）\nhttp://www.tdchat4.com/（已失效）\nhttps://chat35.com/chat（已失效）\nhttps://ai.meiko.ink/（已失效）\nhttps://chat.lkong.org/（已失效）\n 需要api-key\nhttps://chat.forchange.cn/\nhttp://itecheasy.com.cn/\nhttps://ai.yiios.com/\n 需要登录\n\n不推荐使用\n\nhttps://chat.zecoba.cn/（已失效）\nhttps://chat.eaten.fun/（已失效）\nhttps://chat.paoying.net/（已失效）\nhttps://chat.alpaca-bi.com/（已失效）\nhttps://chat.qingting.work/（已失效）\n 下面是嵌入网页，可以直接使用\n\n1.目前用过最快的一个镜像ChatGPT网站，需要验证码\n2.因为不确定因素，该镜像链接可能随时被封禁，请珍惜使用！\n3.网址：https://chat.gpt.bz/\n\n\n\n","categories":["测试区"],"tags":["AI","ChatGPT"]},{"title":"博客添加新的菜单栏","url":"/2023/03/23/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-03-23_%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E8%8F%9C%E5%8D%95%E6%A0%8F/","content":" 博客添加新的菜单栏\n\n例如添加 test 菜单栏\n\n\n在_config.yml文件中添加新的菜单项\n\nmenus:  home: /  books: /books  progress: /progress  categories: /categories  archive: /archives  friends: /links    test: /test\n\n在source文件夹中添加 test 文件夹，文件夹中添加index.md 文件\n\n文件内容：\n---title: testlayout: test---\n\n在zh-CN.yml和en.yml文件中添加 翻译\n\n","categories":["文档区"],"tags":[]},{"title":"安卓app内嵌网页","url":"/2023/03/12/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-03-12_%E5%AE%89%E5%8D%93app%E5%86%85%E5%B5%8C%E7%BD%91%E9%A1%B5/","content":" app内嵌网页\n 申请网络权限\n\n在 AndroidManifest.xml 文件中添加获取权限\n\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;\n 放置Web控件\n&lt;WebView      android:id=&quot;@+id/web&quot;      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;match_parent&quot;/&gt;\n 调用网页\npublic WebView webView;//以下代码在onCreate()之内webView = (WebView) findViewById(R.id.web);  webView.setWebViewClient(new WebViewClient()&#123;      @Override      public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;          view.loadUrl(url);          return true;    &#125;  &#125;);  webView.getSettings().setJavaScriptEnabled(true);  //允许使用jswebView.loadUrl(&quot;https:/a.com&quot;);","categories":["文档区"],"tags":["Android"]},{"title":"C++指针易错知识点","url":"/2023/01/04/%E6%96%87%E6%A1%A3%E5%8C%BA/2023-01-04_C++%E6%8C%87%E9%92%88%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"int a=1;int *p=&amp;a;  //定义一个指向a变量地址的指针p //表示指针的名字*p //表示指针所指向的内容，*p 也就等同于 a&amp;p //指针p的地址，注意不是指向的地址。&amp;a //变量a的地址int *p=&amp;a; //声明指针*p=&amp;a; //这样是不行的，这种结构只能在声明指针变量的时候使用\t   //如果要把另一个变量的地址赋值都指针中，应该写出p=&amp;b;*p1=*p2; //表示把p1指针所指向的值更改为p2指针所指向的值p1=p2; //表示把P1指向的地址（存储在指针中的地址）更改为P2指向的地址*p1=p2;  //错误p1=*p2;  //错误  //p1是指针a=*p2;  //表示把p2所指向的值赋值给a变量，  a是变量\n this指针：\n每个成员函数中都包含一个特殊的指针，就是this指针\n哪个对象调用了这个函数，this指针就指向这个对象\n","categories":["文档区"],"tags":["C++"]},{"title":"更新测试","url":"/2023/01/02/%E6%B5%8B%E8%AF%95%E5%8C%BA/2023-01-02_%E6%9B%B4%E6%96%B0%E6%B5%8B%E8%AF%95/","content":"好久没写博客了,发布篇测试文章 ,用于测试博客上传GitHub是否正常!\n看到这篇文章 ,证明一切顺利.\n\n","categories":["测试区"],"tags":[]},{"title":"C++使用SOCKET进行通信","url":"/2022/10/28/%E6%96%87%E6%A1%A3%E5%8C%BA/2022-10-28_C++%E4%BD%BF%E7%94%A8SOCKET%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1/","content":" SOCKET通信:\n 所需头文件和函数\n 头文件\n#include &lt;iostream&gt;#include &lt;winsock2.h&gt; //socket头文件#pragma comment(lib,&quot;ws2_32.lib&quot;) //导入静态链接库\n 函数\n 服务器端\nsocket()//生成SOCKET对象，并指定（地址族，socket类型，指定协议）\tSOCKET S_socket = socket(AF_INET, SOCK_STREAM, 0);bind()//把结构体中地址的信息，组合好传递给套接字（套接字对象，结构体信息的指针，结构体信息的长度）,返回0表示绑定成功     bind(listen_socket, (SOCKADDR*)&amp;S_sockaddr, sizeof(SOCKADDR));listen()//监听套接字（套接字对象，最大连接数）\tlisten(listen_socket, 10);accept()//将连接到服务器的客户端地址信息存储到，结构体中和SOCKET中\tC_socket = accept(listen_socket, (SOCKADDR*)&amp;C_sockaddr, &amp;len);send()//将缓冲区内的数据通过套接字发送出去（SOCKET对象，缓存变量，字节长度，默认行为0）\tsend(C_socket, send_buf, 100, 0);\trecv()//将soctet缓冲区内的数据读取出来保存到对应变量（SOCKET对象，存储变量，读取字节数，行为默认0）\trecv(C_socket, recv_buf, 100, 0);#### 客户端socket()inet_addr()把IP地址进行转换，以便保存在结构体中（winsock2.h不可用，winsock.h可用）htons()connect()//连接服务器（服务器SOCKET对象，服务器SOCKET地址，服务器SOCKET地址长度）\tconnect(S_socket, (SOCKADDR*)&amp;S_sockaddr, sizeof(SOCKADDR))\tsend()recv()\n SOCKET初始化\nvoid initSocket() &#123;    //初始化套接字库    WORD w_req = MAKEWORD(2, 2);//版本号    WSADATA wsadata;    int err;    err = WSAStartup(w_req, &amp;wsadata);    if (err != 0) &#123;        cout &lt;&lt; &quot;初始化套接字库失败&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;初始化套接字库成功&quot; &lt;&lt; endl;    &#125;    //检测版本号    if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) &#123;        cout &lt;&lt; &quot;套接字库版本号不符&quot; &lt;&lt; endl;        WSACleanup();    &#125;    else &#123;        cout &lt;&lt; &quot;套接字库版本正确&quot; &lt;&lt; endl;    &#125;&#125;\n 全部代码\n 服务器端\n#include &lt;iostream&gt;#include &lt;winsock2.h&gt;//导入静态链接库#pragma comment(lib,&quot;ws2_32.lib&quot;)using namespace std;void initSocket();  //声明套接字初始化函数int main()&#123;    //执行套接字初始化函数    initSocket();    //生成用于监听的SOCKET对象，并指定（地址族，socket类型，指定协议）    SOCKET listen_socket = socket(AF_INET, SOCK_STREAM, 0);    //创建存储套接字地址信息的结构体    SOCKADDR_IN S_sockaddr;    S_sockaddr.sin_family = AF_INET;    //设置地址族    S_sockaddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//设置IP地址，htonl    S_sockaddr.sin_port = htons(9966); //设置端口号    /*        INADDR_ANY表示任何地址，也就是不指定具体IP地址        htons()把short型值转成按网络字节顺序排列的short型值        htonl()把long型值转成按网络字节顺序排列的long型值    */    //把结构体中地址的信息，组合好传递给套接字（套接字对象，结构体信息的指针，结构体信息的长度）    if (0 == bind(listen_socket, (SOCKADDR*)&amp;S_sockaddr, sizeof(SOCKADDR))) &#123;           cout &lt;&lt; &quot;套接字绑定信息成功&quot;&lt;&lt;endl;    &#125;    else &#123;          cout &lt;&lt; &quot;套接字绑定信息失败&quot;&lt;&lt;endl;        WSACleanup();//释放DLL资源    &#125;    //监听套接字（套接字对象，最大连接数）    if (listen(listen_socket, 10) &lt; 0) &#123;        cout &lt;&lt; &quot;设置监听状态失败&quot; &lt;&lt; endl;        WSACleanup();    &#125;    else &#123;        cout &lt;&lt; &quot;设置监听状态成功&quot; &lt;&lt; endl;    &#125;    //创建客户端的SOCKET对象    SOCKET C_socket;    //创建用于存储客户端地址的结构体    SOCKADDR_IN C_sockaddr;    int len = sizeof(SOCKADDR);    //将连接到服务器的客户端地址信息存储到，结构体中    C_socket = accept(listen_socket, (SOCKADDR*)&amp;C_sockaddr, &amp;len);    //判断客户端是否连接成功    if (C_socket == SOCKET_ERROR) &#123;        cout &lt;&lt; &quot;客户端连接失败&quot; &lt;&lt; endl;        WSACleanup();        return 0;    &#125;    else    &#123;        cout &lt;&lt; &quot;客户端连接成功&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl;        int recv_len = 0;        int send_len = 0;        //定义发送缓冲区和接受缓冲区        char recv_buf[100];        char send_buf[100];        while (1) &#123;             //将soctet缓冲区内的数据读取出来保存到对应变量（SOCKET对象，存储变量，读取字节数，行为默认0）            recv_len = recv(C_socket, recv_buf, 100, 0);            if (recv_len &lt; 0) &#123;                cout &lt;&lt; &quot;接收数据失败&quot; &lt;&lt; endl;                break;            &#125;            else &#123;                cout &lt;&lt; &quot;客户端:&quot; &lt;&lt; recv_buf &lt;&lt; endl;            &#125;            /*            cout &lt;&lt; &quot;请输入:&quot;;            cin &gt;&gt; send_buf;            //将缓冲区内的数据通过套接字发送出去（SOCKET对象，缓存变量，字节长度，默认行为0）            send_len = send(C_socket, send_buf, 100, 0);            if (send_len &lt; 0) &#123;                cout &lt;&lt; &quot;发送失败！&quot; &lt;&lt; endl;                break;            &#125;            */        &#125;    &#125;    /*    //关闭套接字    closesocket(S_socket);    closesocket(C_socket);    //释放DLL资源    WSACleanup();    */    return 0;&#125;void initSocket() &#123;    //初始化套接字库    WORD w_req = MAKEWORD(2, 2);//版本号    WSADATA wsadata;    int err;    err = WSAStartup(w_req, &amp;wsadata);    if (err != 0) &#123;        cout &lt;&lt; &quot;初始化套接字库失败&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;初始化套接字库成功&quot; &lt;&lt; endl;    &#125;    //检测版本号    if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) &#123;        cout &lt;&lt; &quot;套接字库版本号不符&quot; &lt;&lt; endl;        WSACleanup();    &#125;    else &#123;        cout &lt;&lt; &quot;套接字库版本正确&quot; &lt;&lt; endl;    &#125;&#125;\n\n 客户端\n#include &lt;iostream&gt;#include&lt;WinSock.h&gt;//导入静态链接库#pragma comment(lib,&quot;ws2_32.lib&quot;)using namespace std;void initSocket();//声明SOCKET初始化函数int main()&#123;    //执行SOCKET初始化函数    initSocket();    //生成SOCKET对象，并指定（地址族，socket类型，指定协议）    SOCKET S_socket = socket(AF_INET, SOCK_STREAM, 0);    //创建存储套接字地址信息的结构体    SOCKADDR_IN S_sockaddr;    S_sockaddr.sin_family = AF_INET;    //设置地址族    S_sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//设置IP地址，inet_addr    S_sockaddr.sin_port = htons(9966); //设置端口号    //连接服务器（客户端SOCKET对象，服务器SOCKET地址，服务器SOCKET地址长度）    if (connect(S_socket, (SOCKADDR*)&amp;S_sockaddr, sizeof(SOCKADDR)) == SOCKET_ERROR) &#123;        cout &lt;&lt; &quot;服务器连接失败&quot; &lt;&lt; endl;        WSACleanup();    &#125;    else &#123;        cout &lt;&lt; &quot;服务器连接成功&quot; &lt;&lt; endl;        char send_buf[100];        char recv_buf[100];        int send_len = 0;        int recv_len = 0;        while (1) &#123;            cout &lt;&lt; &quot;请输入:&quot;;            cin &gt;&gt; send_buf;            send_len = send(S_socket, send_buf, 100, 0);            if (send_len &lt; 0) &#123;                cout &lt;&lt; &quot;发送失败！&quot; &lt;&lt; endl;                break;            &#125;            /*            recv_len = recv(S_socket, recv_buf, 100, 0);            if (recv_len &lt; 0) &#123;                cout &lt;&lt; &quot;接收数据失败&quot; &lt;&lt; endl;                break;            &#125;            else &#123;                cout &lt;&lt; &quot;客户端:&quot; &lt;&lt; recv_buf &lt;&lt; endl;            &#125;            */        &#125;    &#125;    return 0;&#125;void initSocket() &#123;    //初始化套接字库    WORD w_req = MAKEWORD(2, 2);//版本号    WSADATA wsadata;    int err;    err = WSAStartup(w_req, &amp;wsadata);    if (err != 0) &#123;        cout &lt;&lt; &quot;初始化套接字库失败&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;初始化套接字库成功&quot; &lt;&lt; endl;    &#125;    //检测版本号    if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) &#123;        cout &lt;&lt; &quot;套接字库版本号不符&quot; &lt;&lt; endl;        WSACleanup();    &#125;    else &#123;        cout &lt;&lt; &quot;套接字库版本正确&quot; &lt;&lt; endl;    &#125;&#125;","categories":["文档区"],"tags":["通信","C++"]},{"title":"Linux创建并管理用户","url":"/2022/09/26/%E6%96%87%E6%A1%A3%E5%8C%BA/2022-09-26_Linux%E5%88%9B%E5%BB%BA%E5%B9%B6%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7/","content":" 创建用户名和密码\nsudo useradd -m &lt;用户名&gt;\n\n-m 　自动建立用户目录。\n\nsudo passwd  &lt;用户名&gt; # 之后输入两次密码\n 切换用户\nsu &lt;用户名&gt;\n如果是新装系统，切换到su root时候报错（su: Authentication failure），就输入sudo passwd root设置root的密码。\n 给予权限\nsudo vim /etc/sudoers\n在user privilege这一项进行修改\n 删除用户\nsudo userdel -r &lt;用户名&gt;\n 连接远程用户\n使用ssh连接工具，Windows自带的PowerShell也可以\nssh uerlink@120.20.200.200   # 输入你的用户名和远程服务器的ip\n如果每次使用ip连接，又没有国内备案的域名。就可以修改window的host文件添加本地域名解析到ip。\n 退出用户登录\nctrl + d 或者 exit\n Linux设置默认启动用户\n在PowerShell中输入\ndebian config --default-user root\n😁\n","categories":["文档区"],"tags":["Linux"]},{"title":"Linux子系统远程访问","url":"/2022/09/26/%E6%96%87%E6%A1%A3%E5%8C%BA/2022-09-26_Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/","content":" 安装ssh服务\napt-get remove openssh-server\napt-get install openssh-server\n 编辑sshd_config文件\nvim /etc/ssh/sshd_config\nPort 2222  #&gt;设置ssh的端口号, 由于22在windows中有别的用处, 尽量不修改系统的端口号PermitRootLogin yes   #&gt;可以root远程登录PasswordAuthentication yes     #&gt;密码验证登录\n 重启服务\nsudo service ssh --full-restart\n 启动ssh\nsudo service sshd start\n 内网穿透\n把子系统的ip地址做映射\n有公网ip就不用啦，没有就用花生壳之类的软件\n 固定ip地址\n因为wsl2以后，每次重新启动时候。Linux子系统会随机分配ip，然后内外穿透的ip就解析不到Linux的ip和端口\n 解决办法\n创建一个脚本在Windows开机以后，分配一个固定的虚拟ip给Linux子系统，然后解析到虚拟ip上面\n1.bat脚本\n\n把debian替换成你自己的系统，ip默认是192.168.50.16（可以自己改）\n\n::强制获取管理员运行权限%1 mshta vbscript:CreateObject(&quot;Shell.Application&quot;).ShellExecute(&quot;cmd.exe&quot;,&quot;/c %~s0 ::&quot;,&quot;&quot;,&quot;runas&quot;,1)(window.close)&amp;&amp;exitwsl -d debian -u root ip addr add 192.168.50.16/24 broadcast 192.168.50.255 dev eth0 label eth0:1netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.50.88 255.255.255.0\n2.把bat脚本放在Windows启动目录\n%programdata%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n 另一个问题\nssh连接内网穿透的域名，你可能还是无法使用，是因为Linux的ssh没有启动，你可以设置开机启动。\n 开机自启ssh\nsudo systemctl enable ssh\nsudo /etc/init.d/ssh start\n ssh连接\nssh fzl@120.12.1.21 -p2222\n\n-p后面是端口号\n\nhostname -I\n\n显示linux系统的ip地址\n\n\n\n😁\n\n\n","categories":["文档区"],"tags":["Linux"]},{"title":"Linux运行C++程序","url":"/2022/09/25/%E6%96%87%E6%A1%A3%E5%8C%BA/2022-09-25_Linux%E8%BF%90%E8%A1%8CC++%E7%A8%8B%E5%BA%8F/","content":" 运行C++程序\n 安装gcc包\nsudo apt install build-essential\ngcc --version # 查看是否安装成功\n 安装失败\n有可能是镜像源的问题，使用下面的应该能成功\ndeb http://mirrors.cloud.tencent.com/debian/ bullseye main non-free contribdeb http://mirrors.cloud.tencent.com/debian-security bullseye/updates maindeb http://mirrors.cloud.tencent.com/debian/ bullseye-updates main non-free contribdeb http://mirrors.cloud.tencent.com/debian/ bullseye-backports main non-free contribdeb-src http://mirrors.cloud.tencent.com/debian-security bullseye/updates maindeb-src http://mirrors.cloud.tencent.com/debian/ bullseye main non-free contribdeb-src http://mirrors.cloud.tencent.com/debian/ bullseye-updates main non-free contribdeb-src http://mirrors.cloud.tencent.com/debian/ bullseye-backports main non-free contrib\n 编写代码\n直接vim里面写就可以了\nvim test.cpp\n using：函数\n 编译代码\ng++ test.cpp -o test   # -o后面表示生成可执行文件名\ng++ test.cpp # 这样直接编译也行，只不过可能会找不到\n 运行代码\n在可执行文件的文件夹下：\n./test   # ./后面写可执行文件名\n","categories":["文档区"],"tags":["Linux"]},{"title":"Linux配置git","url":"/2022/09/25/%E6%96%87%E6%A1%A3%E5%8C%BA/2022-09-25_Linux%E9%85%8D%E7%BD%AEgit/","content":" 配置git\n 下载git\nsudo apt-get install git\n 初始化git\ngit config --global user.name “名字”\ngit config --global user.email 邮箱\n//–global 表示全局配置\n 常用git命令\n","categories":["文档区"],"tags":["Linux","git"]},{"title":"Vim编辑器常用命令","url":"/2022/09/25/%E6%96%87%E6%A1%A3%E5%8C%BA/2022-09-25_Vim%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"x 删除光标后一个字符\nd + ←→删除光标←→字符（d +3←）、dd删除一行（其实是剪切，p粘贴）\ny+ ←→复制光标←→字符 （y+3←）\nc 删除并进入写入模式、w 光标向下移动一个词、cw删除一个词并进入写入模式、b光标到上一个词 、ciw词中删除一个词并进入写入模式，yi\nf 找词\n/ 搜索、n下 N上\n【y i c d f 】\nesc 回到正常模式\n：w保存\n：q退出vim\n：source $MYVIMRC 刷新vim\njkhl上下左右\n：split 上下分屏 、：vsplit 左右分屏 Q退出\n~/.vim/vimrc\nnoremap a b a键改b键\nmap a b a键改b键\nsyntax on 打开高亮\nset number 显示行号\nset wildmenu ：命令补全\nset hlsearch /搜索高亮\nset incsearch 一面输入一面高亮\n","categories":["文档区"],"tags":["Vim"]},{"title":"Linux安装vim","url":"/2022/09/24/%E6%96%87%E6%A1%A3%E5%8C%BA/2022-09-24_Linux%E5%AE%89%E8%A3%85vim/","content":" 安装vim\n用的是debian系统\n 更新系统镜像源\nsudo cp /etc/apt/sources.list /etc/apt/sources.list_bak # 备份一下软件源\nsudo vi /etc/apt/sources.list\n如果是vi编辑器就进入list文件后直接 “:.,$d” 清空文件，然后粘贴下面的镜像源\n按esc，然后输入 “:wq” 保存并退出\ndeb http://mirrors.cloud.tencent.com/debian/ bullseye main non-free contribdeb http://mirrors.cloud.tencent.com/debian-security bullseye/updates maindeb http://mirrors.cloud.tencent.com/debian/ bullseye-updates main non-free contribdeb http://mirrors.cloud.tencent.com/debian/ bullseye-backports main non-free contribdeb-src http://mirrors.cloud.tencent.com/debian-security bullseye/updates maindeb-src http://mirrors.cloud.tencent.com/debian/ bullseye main non-free contribdeb-src http://mirrors.cloud.tencent.com/debian/ bullseye-updates main non-free contribdeb-src http://mirrors.cloud.tencent.com/debian/ bullseye-backports main non-free contrib\n 更新镜像\nsudo apt-get update\nsudo apt-get upgrade\n 安装软件\napt-get install vim\n 报错解决\nsudo apt-get purge vim-common\nsudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install vim\n","categories":["文档区"],"tags":["Linux","Vim"]},{"title":"《时间的秩序》","url":"/2022/08/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2022-08-19_%E6%97%B6%E9%97%B4%E7%9A%84%E7%A7%A9%E5%BA%8F/","content":" 内容介绍：\n在我们的直觉里，时间是全宇宙统一的，稳定地从过去流向未来，可以用钟表度量。可罗韦利向我们揭示出一个奇怪的宇宙，在这里，时间的特质一一坍塌，在基本的层面上，时间消失了。他告诉我们，我们对时间流逝的感知，取决于我们的视角……\n\n\n        \n            \n        \n        \n            《时间的秩序》\n        \n\n\n 语录\n\n在进步的历程中，我们认识到，一些看似不证自明的事，实际上仅仅是偏见。天空在我们之上而非之下，这似乎显而易见，不然地球就会坠落。地球静止不动似乎是不言而喻的，否则它就会让一切都撞毁。时间在任何地方都以同样的速度流逝，对我们来说也同样是显而易见的……孩子会长大，发现小时候从四壁之家望出去看到的并不是世界的全貌，作为共同体的人类也是一样。\n为什么我们记得过去，而非未来？是我们存在于时间之内，还是时间存在于我们之中？说时间“流逝”到底意味着什么？是什么把时间与我们作为人的本性，与我们的主观性联系在一起？\n\n 感想\n 疑问\n","categories":["读书笔记"],"tags":["读书笔记"]},{"title":"《中国太阳》","url":"/2022/08/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2022-08-19_%E4%B8%AD%E5%9B%BD%E5%A4%AA%E9%98%B3/","content":" 记得仰望星空！！！\n这本书，节奏很快。一个仅上个过3年小学的，农村小伙子。到最后驾驶着由“中国太阳“改造后的飞船，向着太阳系之外探索。\n”这个世界机遇很多，天上到处都是金色的飞鸟“\n”不要丢失，探索宇宙的目标“\n","categories":["读书笔记"],"tags":["读书笔记"]},{"title":"3d模型嵌入测试","url":"/2022/07/17/%E6%B5%8B%E8%AF%95%E5%8C%BA/2022-07-17_3d%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%85%A5%E6%B5%8B%E8%AF%95/","content":" hexo框架下博客页面嵌入3D模型\n\n模型网站：&quot;https://hub.realibox.com/\n\n 模型预览：\n\n\n\n 模型分享：\n\n此3D模型&nbsp;&nbsp;&nbsp;&nbsp;下载\n","categories":["测试区"],"tags":[]},{"title":"读书技巧","url":"/2022/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2022-06-20_%E8%AF%BB%E4%B9%A6%E6%8A%80%E5%B7%A7/","content":" 新手读书技巧\n\n专业性书籍和文学性书籍分开时间段读\n读书的第一个阶段是养成习惯, 选择自己能够较为轻松理解的书籍阅读\n不要刻意的去学习读书方式/方法, 读书的方法是在长时间的习惯中养成的, 适合自己的才是最好的\n\n 2022-06-21\n\n看书或者做事, 都应该计算好每一件事, 所需要的时间, 以便于我们能够更好的合理的安排时间\nT型读书法, H型读书法\n\n","categories":["读书笔记"],"tags":["读书笔记"]},{"title":"php连接数据库并执行sql语句查询","url":"/2022/06/16/%E6%96%87%E6%A1%A3%E5%8C%BA/2022-06-16_php%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5%E6%9F%A5%E8%AF%A2/","content":" php连接数据库并执行sql语句查询：通过html表单提交数据给php\n 效果图\n\n\n\t\n\t\t\n\t\t登录\n\t\n\t\n\t\t\n\t\t\t用户名:\n\t\t\t\n\t\t\t\n\t\t\t密码:\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t \n\t\n\n ---\n 全部文件\n\nindex.php\nindex.html\n\n index.php文件代码:\n\n&lt;?PHP    $date_db=&#x27;test1&#x27;;    $conn=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);//连接字符串    $comm=mysqli_select_db($conn,$date_db);//利用连接字符串选择数据库    $username = addslashes($_POST[&#x27;username&#x27;]);//得到数据    $password = addslashes($_POST[&#x27;password&#x27;]);//得到数据        $sql_data=&quot;select * from users where userName=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;//sql查询语句赋值给变量    $query= mysqli_query($conn,$sql_data);//利用连接字符串运行sql语句            if($conn)&#123;        echo&quot;--连接MySQL成功--&quot;;            &#125;    else&#123;        echo&quot;--连接MySQL失败--&quot;;        &#125;        if($comm)&#123;        echo&#x27;--连接数据库:&#x27;;        echo $date_db;        echo&#x27;成功--&#x27;;    &#125;     if( mysqli_num_rows($query)&gt;0)&#123;        echo&quot;&lt;br&gt;&quot;;        echo $sql_data;        echo&#x27;----查询成功--&#x27;;    &#125;    else&#123;                       $url=&#x27;index.html&#x27;;       echo &quot;&lt;script&gt;location.href=&#x27;$url&#x27;&lt;/script&gt;&quot;;//跳转指定网页                      echo&quot;&lt;br&gt;&quot;;        echo $sql_data;                echo&#x27;----语句查询失败--&#x27;;    &#125;?&gt;\n index.html文件代码：\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;登录&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;form action=&quot;index.php&quot; method=&quot;post&quot;&gt;\t\t\t用户名:&lt;br&gt;\t\t\t&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;UerLink&quot;&gt;\t\t\t&lt;br&gt;\t\t\t密码:&lt;br&gt;\t\t\t&lt;input type=&quot;text&quot; name=&quot;password&quot; value=&quot;123456&quot;&gt;\t\t\t&lt;br&gt;&lt;br&gt;\t\t\t&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;\t\t&lt;/form&gt; \t&lt;/body&gt;&lt;/html&gt;\n","categories":["文档区"],"tags":["数据库"]},{"title":"桌面语音助手","url":"/2022/05/22/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2022-05-22_%E6%A1%8C%E9%9D%A2%E8%AF%AD%E9%9F%B3%E5%8A%A9%E6%89%8B/","content":" 功能需求:\n\n语音控制台灯\n语音控制…\n将控制信息显示在oled屏幕上\n\n 问题\n以前也做个类似的控制(小爱同学+esp8266+继电器) 但是这个缺点太大了. 不能免唤醒词 必须联网, 控制延迟也很大. 而且不能自定义回答\n 解决方案\n淘宝上买了一个语音控制的模块(SU-03T), 离线语音, 免唤醒, 响应时间很快. 完美符合我的要求. 在线编程自己生成sdk,和固件.\n 思维导图\n\n arduino代码\n#include &lt;Wire.h&gt; // 引入驱动OLED0.96所需的库#include &lt;Adafruit_GFX.h&gt;#include &lt;Adafruit_SSD1306.h&gt;#define SCREEN_WIDTH 128 // 设置OLED宽度,单位:像素#define SCREEN_HEIGHT 64 // 设置OLED高度,单位:像素#define OLED_RESET 4Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);#include &lt;SoftwareSerial.h&gt;  //软串口库SoftwareSerial mySerial(2,3); ////定义软串口，arduino的2号引脚作为RX，arduino的3号引脚作为TX，根据需要自行修改void setup()&#123;  Serial.begin(9600);  mySerial.begin(9600);  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);&#125;void loop()&#123;    DataJC();&#125;//------读取串口void DataJC()&#123;  if (mySerial.available() &gt; 0) //检测软串口是否有数据  &#123;    int val = 0;    val = mySerial.read();//读出串数据    Serial.println(val);  //从主串口打开出来    if (val == 161) &#123;      Serial.println(&quot;A1已开启&quot;);      A1_on();    &#125;    if (val == 162) &#123;      Serial.println(&quot;A1已关闭&quot;);      A1_off();    &#125;    if (val == 17) &#123;      Serial.println(&quot;响应&quot;);      Emoji_1();    &#125;  &#125;&#125;//表情:响应void Emoji_1()&#123;  display.clearDisplay();  display.setTextColor(WHITE);  display.setTextSize(4);  display.setCursor(45, 10);  display.print(&quot;Hi&quot;);  display.display();  delay(1000);  display.clearDisplay();  display.setTextColor(WHITE);  display.setTextSize(4);  display.setCursor(32, 10);  display.print(&quot;o o&quot;);  display.display();  delay(1000);&#125;//打开A1void A1_on()&#123;      display.clearDisplay();      display.setTextColor(WHITE);      display.setTextSize(2);      display.setCursor(0, 20);      display.print(&quot;A1 &gt;&gt; on&quot;);      display.display();      //delay(2000);&#125;//关闭A1void A1_off()&#123;      display.clearDisplay();      display.setTextColor(WHITE);      display.setTextSize(2);      display.setCursor(0, 20);      display.print(&quot;A1 &gt;&gt; off&quot;);      display.display();      //delay(2000);&#125;//向软串口输出数据void send_cmd(int cmd)&#123;  char mylist[9]=&#123;0xAA,0x55,0x01,0x01,0x00,0x00,0x00,0x55,0xAA&#125;;//设置发送列表  //改变数值  mylist[(int)(3)] = cmd;   mySerial.write(mylist[(int)(0)]);  mySerial.write(mylist[(int)(1)]);  mySerial.write(mylist[(int)(2)]);  mySerial.write(mylist[(int)(3)]);  mySerial.write(mylist[(int)(4)]);  mySerial.write(mylist[(int)(5)]);  mySerial.write(mylist[(int)(6)]);  mySerial.write(mylist[(int)(7)]);  mySerial.write(mylist[(int)(8)]);&#125;","categories":["实践项目"],"tags":[]},{"title":"C#项目打包","url":"/2022/05/12/%E6%96%87%E6%A1%A3%E5%8C%BA/2022-05-12_C_sharp%E6%89%93%E5%8C%85/","content":" 安装打包插件\n\n\n在Visual Studio的扩展中搜索installer然后选择并下载创建者为Microsoft的插件(安装量最多的那个).\n\n\n下载完成后会提示关闭当前项目,点击关闭.\n\n\n进行安装.\n\n\n 创建打包项目\n\n\n在Visual Studio启动界面(或者文件选项卡)新建一个Setup Project(如果找不到就搜索模板处输入SetUp).\n\n\n创建完项目后,会出现三个文件夹, 然后再Apelication Folder上右键添加需要打包的文件.\n\n\n添加完成后, 再给启动入口程序, 右键创建快捷方式, 然后拖动到, 剩下两个文件夹中(一个是桌面,一个是开始菜单).\n\n\n接着在属性窗口分别自定义图标.ICON.\n\n\n 生成打包文件\n\n\n右键解决方案下方项目, 点击生成.\n\n\n生成路径在项目文件夹中的Debug文件夹中(如果是Release就在Release文件夹中).\n\n\nDebug下会生成一个exe文件一个msi文件, 两个都可以用, 自行选择.\n\n\n","categories":["文档区"],"tags":["C_sharp"]},{"title":"markdown语法","url":"/2022/05/08/%E6%96%87%E6%A1%A3%E5%8C%BA/2022-05-08_markdown%E8%AF%AD%E6%B3%95/","content":" 一级标题\n 二级标题\n 三级标题\n 四级标题\n 五级标题\n 六级标题\n# 一级标题## 二级标题### 三级标题....\t另一种写法:一级标题===二级标题---\n 段落语法\n空一行是换行\n空两行是换段\n注意换端的时候不要用空格或制表符\n 强调语法\n加粗\n**文字**\n斜体\n*文字*\n 引用语法\n\n引用文字…\n\n&gt; 引用文字\n\n123456\n\n嵌套引用\n12334\n\n\n&gt; 123456&gt;&gt; 嵌套引用&gt; 123456\n\n引用里面加列表\n\n1\n2\n3\n\n\n&gt; 引用里面加列表&gt; - 1&gt; - 2&gt; - 3\n 列表语法\n有序列表\n\n1\n2\n3\n\n1. 12. 23. 3\n无序列表\n\n1\n2\n3\n\n- 1- 2- 3或者+ 1+ 2+ 3或者* 1* 2* 3\n相互嵌套\n\n1\n\n2\n3\n\n\n4\n\n1. 1\t- 2\t- 32. 4\n","categories":["文档区"],"tags":[]},{"title":"机顶盒搭建FTP","url":"/2022/05/04/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2022-05-04_%E6%9C%BA%E9%A1%B6%E7%9B%92%E6%90%AD%E5%BB%BAFTP/","content":" 老旧机顶盒-创维E900S 刷机并搭建FTP服务\n 目录\n\n功能需求:\n设备列表:\n实现过程:\n访问方法:\n\n(ง •_ •)ง 谢谢阅读!\n\n 功能需求:\n\n电脑或手机端,能够随时连接到,外接在机顶盒上的移动硬盘或U盘.\n机顶盒能够正常看电视,并且开机自动启用FTP功能.\n\n 设备列表:\n\n机顶盒 (安装有当贝市场,至于怎么安装刷机包,我也是百度的)\n显示器\n硬盘,U盘\n电脑\n\n\n 实现过程:\n我使用的机顶盒是 创维E900S 芯片为S905L,其他机顶盒可以在当贝社区里面找ROM包\n\n 刷机包以及方法:\n创维E900-ST高安版-S905L芯片ROM固件https://www.znds.com/rom/741079.html\n当贝社区链接https://www.znds.com/rom/down/\n&quot;每步FTP&quot;软件下载地址http://www.meibu.com/soft/ftp.apk\n1.机顶盒刷机成功以后,打开当贝桌面,安装&quot;小白文件管理器app&quot; 使用里面的文件传输功能,上传&quot;每步FTP&quot;app,并安装. 也可以使用当贝自带的上传工具.\n\n2.外接一个U盘或硬盘\n3.打开&quot;小白资源管理器&quot;–文件管理–查看U盘,硬盘路径.\n\n4.打开&quot;每步FTP&quot;–设置–更改路径为硬盘路径.\n\n5.开启&quot;匿名登录&quot;,“保持设备唤醒”–返回\n6.开启FTP服务,成功以后会显示ftp地址\n\n\n**建议:**路由器端分配一个静态ip给机顶盒,不然ftp地址会变.\n**注释:**其实&quot;小白文件管理器&quot;自带FTP功能,但是不能开启自动启用FTP服务,且不能更改FTP映 射路径,所以使用&quot;每步FTP&quot;,网上找了好久才找到这个软件.\n 访问方法:\n 电脑端&gt;\n​    方法一:直接在资源管理器中输入FTP地址,例如&quot;ftp://192.168.10.10:2121/&quot;–回车即可访问.\n​    \n​    方法二:新建一个网络位置,按向导提示,输入FTP地址,下次可以直接在资源管理器中点击访问.\n​    \n 手机端&gt;\n​    下载es文件管理器等软件,里面有FTP服务,连接统一局域网,输入地址即可访问.\n","categories":["实践项目"],"tags":["旧物改造"]},{"title":"C#打开文件夹或文件","url":"/2022/05/04/%E6%96%87%E6%A1%A3%E5%8C%BA/2022-05-04_C_sharp%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9%E6%88%96%E6%96%87%E4%BB%B6/","content":" 选择文件夹\n   private void btn_select(object sender, EventArgs e)   &#123;       //新建dialog对象       FolderBrowserDialog dialog = new FolderBrowserDialog();       //显示文字       dialog.Description = &quot;选择文件夹&quot;;       //默认路径       dialog.SelectedPath = @&quot;C:&quot;;       //判断文件夹路径是否为空       if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)       &#123;           if (string.IsNullOrEmpty(dialog.SelectedPath))           &#123;               //为空提醒               MessageBox.Show(this, &quot;文件夹路径不能为空&quot;, &quot;提示&quot;);               return;           &#125;           //命令行提示           Console.WriteLine(&quot;选择了：&quot; + dialog.SelectedPath);        &#125;       //保存路径string FilesPath = dialog.SelectedPath;   &#125;\n 选择文件\n   private string SelectPath()   &#123;       string Path = String.Empty;       OpenFileDialog dialog = new OpenFileDialog();       dialog.Multiselect = true;//该值确定是否可以选择多个文件       //提示文字       dialog.Title = &quot;请选择文件夹&quot;;       //设置选择文件类型（）显示的文件 | 过滤的文件       dialog.Filter = &quot;所有文件(*.*)|*.*&quot;;       if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)       &#123;           //变量赋值路径           Path = dialog.FileName;       &#125;//返回文件路径       return Path;   &#125;\n 打开文件或文件夹\n//填入文件或文件夹的路径。//默认System.Diagnostics.Process.Start(&quot;ExpLorer&quot;, &quot;C:\\\\window&quot;); //选择文件打开方式，并打开    // 目标文件路径 \tstring StartPath = Application.StartupPath + @&quot;\\scripts\\starthw.bat&quot;;    //（方法1） 记事本（特定程序）    string NotPath = System.Environment.SystemDirectory + &quot;\\\\notepad.exe&quot;;    System.Diagnostics.Process.Start(NotPath, StartPath);        //（方法2） 设置打开方式路径    string OpenPath = @&quot;C:\\Program Files (x86)\\sakura\\sakura.exe&quot;;    System.Diagnostics.Process.Start(OpenPath, StartPath);   \n","categories":["文档区"],"tags":["C_sharp"]},{"title":"C#创建并连接数据库以及增删查改","url":"/2022/05/04/%E6%96%87%E6%A1%A3%E5%8C%BA/2022-05-04_C_sharp%E6%93%8D%E6%8E%A7Access%E6%95%B0%E6%8D%AE%E5%BA%93/","content":" 引入命名空间\nusing System.Data.OleDb;using System.IO;using ADOX;\n 动态创建数据库\n//数据库路径String filePath = &quot;C:\\\\Users\\\\18144\\\\OneDrive\\\\文档\\\\Access\\\\test2.accdb&quot;;if (!File.Exists(filePath))&#123;//数据库不存在// 创建Access数据库   ADOX.Catalog catalog = new ADOX.Catalog();   catalog.Create(&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source = C:\\\\Users\\\\18144\\\\OneDrive\\\\文档\\\\Access\\\\test2.accdb;Jet OLEDB:Database Password = 123456&quot;);   //Data Source = .\\\\Data\\\\Student.accdb;  当前位置创建       //释放Catalog对数据库文件的占用   System.Runtime.InteropServices.Marshal.FinalReleaseComObject(catalog.ActiveConnection);   System.Runtime.InteropServices.Marshal.FinalReleaseComObject(catalog);    return; &#125;else&#123;    //数据库已存在    MessageBox.Show(&quot;数据库文件已存在&quot;);         &#125;\n 创建数据表\n//合并连接字符串string DataLinkString = &quot;Provider = Microsoft.Jet.OLEDB.4.0;&quot;;DataLinkString += @&quot;Data Source = C:\\Users\\18144\\OneDrive\\文档\\Access\\test2.accdb;&quot;;DataLinkString += @&quot;Jet OLEDB:Database Password = 123456&quot;;//根据连接字符串，连接数据库OleDbConnection AD = new OleDbConnection(DataLinkString);//开启数据库AD.Open();//创建sql命令---删除表命令OleDbCommand sql_cmd1 = new OleDbCommand(&quot;drop table Info&quot;, AD);//执行sql命令sql_cmd1.ExecuteNonQuery();sql_cmd1.Dispose();//创建sql命令----创建表命令OleDbCommand sql_cmd2 = new OleDbCommand(&quot;create table Info (id char(15) primary key, name char(50))&quot;, AD);//执行sql命令sql_cmd2.ExecuteNonQuery();sql_cmd2.Dispose();//关闭数据库AD.Close();AD.Dispose();\n 执行sql命令\nprivate void RunSQL(string sql_cmd)&#123;    //void作用：运行sql代码//    try    &#123;        //合并连接字符串        string DataLinkString = &quot;Provider = Microsoft.Jet.OLEDB.4.0;&quot;;        DataLinkString += @&quot;Data Source = C:\\Users\\18144\\OneDrive\\文档\\Access\\test2.accdb;&quot;;        DataLinkString += @&quot;Jet OLEDB:Database Password = 123456&quot;;        //根据连接字符串，连接数据库        OleDbConnection conn = new OleDbConnection(DataLinkString);        //开启数据库        conn.Open();        //创建sql命令        OleDbCommand cmd = new OleDbCommand(sql_cmd, conn);        //执行sql命令        cmd.ExecuteNonQuery();        cmd.Dispose();        //关闭数据库        conn.Close();        conn.Dispose();    &#125;    catch (Exception e)    &#123;        MessageBox.Show(e.ToString(), &quot;提示&quot;);    &#125;&#125;\n 增加\n//sql增加命令string insert = &quot;insert into student values(&quot; + id + &quot;, &#x27;&quot; + name + &quot;&#x27;, &quot; + age + &quot;);&quot;;RunSQL(insert);\n 删除\n//sql删除命令string delete = &quot;delete from student where id = &quot; + id;RunSQL(delete);\n 修改\n//sql修改命令string update = &quot;update student set Name = &#x27;&quot; + name + &quot;&#x27;, Age = &quot; + age + &quot; where Id = &quot; + id;RunSQL(update);\n 查询\n         // 如果连接是关闭的，才进行打开          if (odc.State == ConnectionState.Closed) &#123;              conn.Open();          &#125;// sql操作语句          string select = &quot;select * from student where Age = &quot; + age;          // 创建设配器对象   【OleDbDataAdapter】          OleDbDataAdapter dbDataAdapter = new OleDbDataAdapter(select, cmd);          // 新建表对象          DataTable dataTable = new DataTable();          // 用设配器对象填充表对象          dbDataAdapter.Fill(dataTable);          // 将查找到的数据遍历输出          foreach (DataRow dr in dataTable.Rows) &#123;              Console.WriteLine(&quot;id = &#123;0&#125; name = &#123;1&#125; age = &#123;2&#125;&quot;, dr[0], dr[1], dr[2]);          &#125;\n","categories":["文档区"],"tags":["C_sharp","数据库"]}]