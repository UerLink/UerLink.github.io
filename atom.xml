<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UerLink_Blog</title>
  
  
  <link href="http://uerlink.github.io/atom.xml" rel="self"/>
  
  <link href="http://uerlink.github.io/"/>
  <updated>2025-06-24T15:56:49.717Z</updated>
  <id>http://uerlink.github.io/</id>
  
  <author>
    <name>UerLink</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>名句</title>
    <link href="http://uerlink.github.io/2025/06/03/%E2%80%8B%E8%BF%81%E6%80%9D%E5%9B%9E%E8%99%91/2025-06-03_%E5%90%8D%E5%8F%A5/"/>
    <id>http://uerlink.github.io/2025/06/03/%E2%80%8B%E8%BF%81%E6%80%9D%E5%9B%9E%E8%99%91/2025-06-03_%E5%90%8D%E5%8F%A5/</id>
    <published>2025-06-02T16:00:00.000Z</published>
    <updated>2025-06-24T15:56:49.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我不知道我的选择是否正确，<br />这是我想要的突破还是循规蹈矩？<br />束缚我的东西太多了，<br />我的迷茫、我的焦虑、我的怯懦。<br />我要冲破这令我窒息的怀疑。<br />我要走，走到春暖花开，山高海阔；<br />我要走，走到人声鼎沸，灯火通明。<br />所以自由的第一枪由我打响，<br />我会一而再，再而三地救自己于水火，<br />哪怕伤痕累累，精神不死，我亦不屈。<br />命运的洪流不可抵挡，<br />而我的回答是：“向前！”</p></blockquote><div class="post-note note-success"><p>孩儿立志出乡关，学不成名誓不还。<br />埋骨何须桑梓地，人生无处不青山。</p></div><div class="post-note note-success"><p>嗯~</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我不知道我的选择是否正确，&lt;br /&gt;
这是我想要的突破还是循规蹈矩？&lt;br /&gt;
束缚我的东西太多了，&lt;br /&gt;
我的迷茫、我的焦虑、我的怯懦。&lt;br /&gt;
我要冲破这令我窒息的怀疑。&lt;br /&gt;
我要走，走到春暖花开，山高海阔；&lt;br /&gt;
</summary>
      
    
    
    
    <category term="迁思回虑" scheme="http://uerlink.github.io/categories/%E8%BF%81%E6%80%9D%E5%9B%9E%E8%99%91/"/>
    
    
  </entry>
  
  <entry>
    <title>专利认识--- 实用新型专利</title>
    <link href="http://uerlink.github.io/2025/05/26/%E2%80%8B%E8%BF%81%E6%80%9D%E5%9B%9E%E8%99%91/2025-05-26_%E4%B8%93%E5%88%A9%E8%AE%A4%E8%AF%86/"/>
    <id>http://uerlink.github.io/2025/05/26/%E2%80%8B%E8%BF%81%E6%80%9D%E5%9B%9E%E8%99%91/2025-05-26_%E4%B8%93%E5%88%A9%E8%AE%A4%E8%AF%86/</id>
    <published>2025-05-25T16:00:00.000Z</published>
    <updated>2025-05-25T19:30:00.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实用新型专利"><a class="markdownIt-Anchor" href="#实用新型专利"></a> 实用新型专利</h1><h2 id="新知识"><a class="markdownIt-Anchor" href="#新知识"></a> 新知识</h2><p>今天在学习单片机电源设计时，用到了一款SOC芯片IP5306（支持2.4A的同步升压转换和2.1A的同步开关充电），但是呢！有个缺点在外部电源断开时切换为锂电池供电会出现0.5s的断电，单片机就会掉电复位。我想让它不断电像UPS一样就去搜索实现方案，搜索到一篇实用新型专利，我很好奇这个专利中的电路与我搜索的其他电路只多了一个二极管，假如其他人也想到添加一个二极管，那不就侵权了吗？未免不要太容易。</p><p>才发现实用新型专利还像没啥含金量，电路本身不受保护，保护的只是所用的组合方式。假如涉及到侵权那改改二极管型号就可以了。有的时候一些小公司会鼓励员工多申请实用新型专利，来增加公司的专利数，在外人面前提升公司名气。有趣！0_0<br />当然也不是那么差，我只是才了解到这个，随着后续学习可能有新的理解。</p><h2 id="ai回答"><a class="markdownIt-Anchor" href="#ai回答"></a> AI回答</h2><p>实用新型专利与发明专利是我国专利法保护的两种主要类型，二者在保护客体、创造性要求、审查程序等方面存在显著区别。</p><h3 id="一-保护客体"><a class="markdownIt-Anchor" href="#一-保护客体"></a> 一、保护客体</h3><ol><li><p><strong>发明专利</strong><br />保护范围涵盖产品、方法及其改进方案。例如：</p><ul><li><strong>产品发明</strong>：新型材料、机械设备等物质形态创新；</li><li><strong>方法发明</strong>：生产工艺、检测技术等流程性创新。<br />可涉及无固定形状的物质（如液态、气态）。</li></ul></li><li><p><strong>实用新型专利</strong><br />仅保护具有确定形状或构造的实体产品，例如：</p><ul><li>牙刷的结构改进、机械部件的组合优化；</li><li>排除方法类创新（如制造工艺）和未定型产品（如粉末状材料）。</li></ul></li></ol><hr /><h3 id="二-授权标准"><a class="markdownIt-Anchor" href="#二-授权标准"></a> 二、授权标准</h3><ol><li><p><strong>创造性要求</strong></p><ul><li>发明需具备“突出的实质性特点和显著进步”，强调技术突破性；</li><li>实用新型仅需“实质性特点和进步”，对创新高度要求较低。</li></ul></li><li><p><strong>实用性</strong><br />两者均需满足实用性要求，但实用新型更侧重实际应用效果，例如结构优化带来的使用便利性提升。</p></li></ol><hr /><h3 id="三-审查程序与周期"><a class="markdownIt-Anchor" href="#三-审查程序与周期"></a> 三、审查程序与周期</h3><ol><li><p><strong>发明专利</strong></p><ul><li><strong>实质审查制</strong>：需通过新颖性、创造性、实用性全面审查，耗时约2-3年；</li><li>包含18个月公开期及可能的期限补偿（如新药专利最长可延长5年保护）。</li></ul></li><li><p><strong>实用新型专利</strong></p><ul><li><strong>初步审查制</strong>：仅审查形式要件和明显缺陷，授权周期短（通常6-12个月）；</li><li>无实质审查，专利权稳定性相对较低，后续可能需补充“专利权评价报告”验证有效性。</li></ul></li></ol><hr /><h3 id="四-保护期限与费用"><a class="markdownIt-Anchor" href="#四-保护期限与费用"></a> 四、保护期限与费用</h3><table><thead><tr><th>项目</th><th>发明专利</th><th>实用新型专利</th></tr></thead><tbody><tr><td>保护期限</td><td>20年（自申请日起）</td><td>10年（自申请日起）</td></tr><tr><td>申请费用</td><td>约3400元（含实审费）</td><td>约500元</td></tr><tr><td>年费标准</td><td>逐年递增，最高8000元/年</td><td>逐年递增，最高2000元/年</td></tr></tbody></table><hr /><h3 id="五-其他关键差异"><a class="markdownIt-Anchor" href="#五-其他关键差异"></a> 五、其他关键差异</h3><ol><li><p><strong>权利稳定性</strong><br />发明因经过实质审查，无效风险较低；实用新型易因缺乏创造性被宣告无效。</p></li><li><p><strong>申请策略</strong><br />允许同日申请两者（需声明放弃实用新型），以兼顾快速授权与长期保护。</p></li><li><p><strong>适用场景</strong></p><ul><li>发明适合核心技术或生命周期长的创新；</li><li>实用新型适合结构改进型产品或需快速商业化的技术。</li></ul></li></ol><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实用新型专利&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实用新型专利&quot;&gt;&lt;/a&gt; 实用新型专利&lt;/h1&gt;
&lt;h2 id=&quot;新知识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#新知识&quot;&gt;&lt;/a&gt; 新知识&lt;</summary>
      
    
    
    
    <category term="迁思回虑" scheme="http://uerlink.github.io/categories/%E8%BF%81%E6%80%9D%E5%9B%9E%E8%99%91/"/>
    
    
    <category term="专利" scheme="http://uerlink.github.io/tags/%E4%B8%93%E5%88%A9/"/>
    
    <category term="新知识" scheme="http://uerlink.github.io/tags/%E6%96%B0%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>电焊笔记</title>
    <link href="http://uerlink.github.io/2025/04/28/%E6%96%87%E6%A1%A3%E5%8C%BA/2025/2025-04-28_%E7%94%B5%E7%84%8A%E7%AC%94%E8%AE%B0/"/>
    <id>http://uerlink.github.io/2025/04/28/%E6%96%87%E6%A1%A3%E5%8C%BA/2025/2025-04-28_%E7%94%B5%E7%84%8A%E7%AC%94%E8%AE%B0/</id>
    <published>2025-04-27T16:00:00.000Z</published>
    <updated>2025-04-28T12:14:16.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电焊练习笔记"><a class="markdownIt-Anchor" href="#电焊练习笔记"></a> 电焊练习笔记</h1><p>今天尝试学习焊接，焊接的镀锌方管，结果焊不上直接烧穿了。又焊了一把断刀，这个厚一点就成功了。</p><h3 id="笔记"><a class="markdownIt-Anchor" href="#笔记"></a> 笔记</h3><ol><li>焊接薄镀锌方管时，电流要调小，间断性的焊接，小焊条更好。</li><li>焊条接触时要滑动来点火（电弧），不要直接点容易粘住。</li><li><strong>焊接件上不能有水，容易爆炸</strong>（炸得到处都是融化的铁水）。</li><li>焊条需要干燥保存。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电焊练习笔记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#电焊练习笔记&quot;&gt;&lt;/a&gt; 电焊练习笔记&lt;/h1&gt;
&lt;p&gt;今天尝试学习焊接，焊接的镀锌方管，结果焊不上直接烧穿了。又焊了一把断刀，这个厚一点就成功了。&lt;/p&gt;
&lt;h3 id=&quot;笔</summary>
      
    
    
    
    <category term="文档区" scheme="http://uerlink.github.io/categories/%E6%96%87%E6%A1%A3%E5%8C%BA/"/>
    
    
    <category term="笔记" scheme="http://uerlink.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电焊" scheme="http://uerlink.github.io/tags/%E7%94%B5%E7%84%8A/"/>
    
    <category term="技能" scheme="http://uerlink.github.io/tags/%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>实用Linux命令</title>
    <link href="http://uerlink.github.io/2025/04/24/%E6%96%87%E6%A1%A3%E5%8C%BA/2025/2025-04-24_%E5%AE%9E%E7%94%A8Linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://uerlink.github.io/2025/04/24/%E6%96%87%E6%A1%A3%E5%8C%BA/2025/2025-04-24_%E5%AE%9E%E7%94%A8Linux%E5%91%BD%E4%BB%A4/</id>
    <published>2025-04-23T16:00:00.000Z</published>
    <updated>2025-04-23T15:31:15.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-linux常用命令"><a class="markdownIt-Anchor" href="#一-linux常用命令"></a> 一 linux常用命令</h2><h3 id="linux常用命令分类"><a class="markdownIt-Anchor" href="#linux常用命令分类"></a> Linux常用命令分类：</h3><p>(1) 文件传输：ftp、tftp。</p><p>(2) 备份解压： bunzip2、 bzip2、 compress、 gunzip、 gzip、 tar、 unzip、 zip、 zipinfo。</p><p>(3) 文件管理：diff、file、find、ln、locate、mv、rm、touch、cat、chmod、cp。</p><p>(4) 磁盘管理：cd、df、du、ls、mkdir、pwd、mount、umount、tree、stat、fdisk。</p><p>(5) 系统设置：alias、unalias、lsmod、insmod、rmmod、modinfo、modprobe、</p><p>export、passwd、rpm、setenv、setup。</p><p>(6) 系统管理：adduser、date、exit、free、halt、id、kill、last、login、logout、</p><p>ps、reboot、shutdown、su、sudo、top、uname、useradd、userdel、who。</p><p>(7) 文档编辑：grep、egrep、fgrep、rgrep、fold、sed、tr、sort。</p><p>(8) 网络通讯：telnet、httpd、minicom、samba、ping、ifconfig、netstat。</p><h4 id="1想知道某个命令的作用"><a class="markdownIt-Anchor" href="#1想知道某个命令的作用"></a> 1.想知道某个命令的作用</h4><p>cmd：<strong>whatis</strong></p><p>用法：</p><p><strong>whatis</strong> <strong>命令名</strong></p><h4 id="2搜索文件或目录路径"><a class="markdownIt-Anchor" href="#2搜索文件或目录路径"></a> 2.搜索文件或目录路径</h4><p>cmd：<strong>locate  文件（目录）名</strong></p><h4 id="3查看目录"><a class="markdownIt-Anchor" href="#3查看目录"></a> 3.查看目录</h4><p>cmd: <strong>ls</strong>    (list)</p><p><strong>ls –a</strong>      可查看当前目录下包括隐藏文件在内的文件（<strong>隐藏文件</strong>以**.**开头）</p><p>ls /etc     查看/etc目录下的内容</p><p><strong>ls –l</strong>      列出详细信息，包括文件大小，访问权限等</p><p>首行字母“-”开头，是文件</p><p>首行字母“d”开头，是目录</p><p>首行字母“l”开头，是软链接文件</p><h4 id="4显示当前路径"><a class="markdownIt-Anchor" href="#4显示当前路径"></a> 4.显示当前路径</h4><p>cmd：<strong>pwd</strong>   （Print Working Directory）</p><p>（1）绝对路径：从根（/：最顶层的目录）开始，如/etc/init.d/lvm</p><p>（2）相对路径：从当前位置开始,如现在的位置为/etc目录中，要进入init.d目录，执行cd init.d</p><p>（3）用户主目录：在这个目录当前用户的权限是最大化</p><p>/home/登录名</p><h4 id="5切换路径"><a class="markdownIt-Anchor" href="#5切换路径"></a> 5.切换路径</h4><p>cmd：<strong>cd</strong>    （change directory）</p><p>用法：（中间均有空格）</p><p>cd 回车     （回到自己的用户主目录）</p><p>cd 登录名   （进入对应的子目录）</p><p><strong>cd</strong> <strong>路径</strong>     （切换到指定路径下）</p><p><strong>cd …</strong>         (切换到上一层目录)</p><p><strong>cd -</strong>         （上一次访问的目录）</p><h4 id="6新建子目录"><a class="markdownIt-Anchor" href="#6新建子目录"></a> 6.新建子目录</h4><p>cmd：<strong>mkdir</strong></p><p>用法：</p><p><strong>mkdir</strong> <strong>目录名</strong>   （在当前路径下新建子目录）</p><p>例如：</p><p>mkdir  dir</p><p>mkdir –p /home/dir/dir1/dir2  建立多级目录，使用-p参数</p><h4 id="7新建一个普通文件"><a class="markdownIt-Anchor" href="#7新建一个普通文件"></a> 7.新建一个普通文件</h4><p>cmd：<strong>touch</strong></p><p>用法：</p><p><strong>touch</strong> <strong>文件名</strong>    （在当前路径下新建一个空白文件）</p><h4 id="8拷贝文件"><a class="markdownIt-Anchor" href="#8拷贝文件"></a> 8.拷贝文件</h4><p>cmd：<strong>cp</strong></p><p>用法：</p><p><strong>cp  src_file  dest_path</strong>             （文件的拷贝）</p><p><strong>cp  src_dir  dest_path  -a</strong>          （目录dir的拷贝）</p><p><strong>cp –r</strong>   递归处理，将指定目录下的文件与子目录一并处理</p><h4 id="9移动"><a class="markdownIt-Anchor" href="#9移动"></a> 9.移动</h4><p>cmd：<strong>mv</strong></p><p>使用：</p><p>（1）mv  file或dir  dest_path</p><p>（2）<strong>mv  old-name  new-name</strong>       修改文件名</p><h4 id="10删除"><a class="markdownIt-Anchor" href="#10删除"></a> 10.删除</h4><p>cmd：<strong>rm</strong></p><p>使用：</p><p>（1）<strong>rm -rf 文件或目录</strong></p><p>（2）<strong>rm -rf</strong>  *</p><p><strong>-r</strong> 删除目录</p><p><strong>-f</strong> 强制删除，即使设置了-i属性也不起作用</p><h4 id="11显示文件内容cat"><a class="markdownIt-Anchor" href="#11显示文件内容cat"></a> 11.显示文件内容：<strong>cat</strong></h4><p>使用：</p><p><strong>cat</strong> <strong>文件名</strong></p><p>cat /home/hello.c</p><h4 id="12显示目录或文件占用的磁盘大小"><a class="markdownIt-Anchor" href="#12显示目录或文件占用的磁盘大小"></a> 12.显示目录或文件占用的磁盘大小</h4><p>cmd：<strong>du</strong></p><p>用法：<strong>du 选项 文件或目录</strong></p><p>du常用选项</p><p><strong>-a</strong> 显示目录中所有文件的大小</p><p><strong>-b</strong> 显示目录或文件大小以byte为单位</p><p><strong>-m</strong> 以MB为单位</p><p><strong>-c</strong> 显示目录中所有文件大小，并显示所有目录和文件的总和</p><h4 id="13显示或设置网络设备"><a class="markdownIt-Anchor" href="#13显示或设置网络设备"></a> 13.显示或设置网络设备</h4><p>cmd：<strong>ifconfig</strong></p><p>用法：</p><p><strong>ifconfig</strong>        查看当前网络设备</p><p><strong>ifconfig</strong> <strong>网络设备名称 选项 地址</strong>         设置网络设备</p><p>例如：</p><p>iconfig eth0 192.168.0.108             重新设置网卡eth0的ip地址</p><p><strong>down</strong>  关闭指定网络设备</p><p><strong>up</strong>     启动指定网络设备</p><p><strong>netmask</strong>  设置网络设备的子网掩码</p><p><strong>网络设备</strong> 指定网络设备的名称</p><h4 id="14查找文件里符合条件的字符串"><a class="markdownIt-Anchor" href="#14查找文件里符合条件的字符串"></a> 14.查找文件里符合条件的字符串</h4><p>cmd：<strong>grep</strong></p><p>用法：</p><p><strong>grep</strong> <strong>选项 查找样式 文件或目录</strong></p><h4 id="15挂载其他文件系统资源"><a class="markdownIt-Anchor" href="#15挂载其他文件系统资源"></a> 15.挂载其他文件系统资源</h4><p>cmd：<strong>mount</strong></p><p><strong>mount</strong> <strong>选项 设备名称 挂载路径</strong></p><h4 id="16阅读命令的文档信息"><a class="markdownIt-Anchor" href="#16阅读命令的文档信息"></a> 16.阅读命令的文档信息</h4><p>cmd：<strong>man</strong></p><p>用法**：**</p><p><strong>man</strong> <strong>命令名</strong></p><h3 id="常用选项"><a class="markdownIt-Anchor" href="#常用选项"></a> 常用选项：</h3><h4 id="1自动补齐快捷键"><a class="markdownIt-Anchor" href="#1自动补齐快捷键"></a> 1.自动补齐快捷键</h4><p>tab键</p><h4 id="2linux压缩文件形式"><a class="markdownIt-Anchor" href="#2linux压缩文件形式"></a> 2.linux压缩文件形式</h4><p>xxx.tar</p><p>xxx.tar.gz</p><p>xxx.tar.bz2</p><p>xxx.tar.xz</p><p>解压命令：</p><p><strong>tar –xvf</strong>  <strong>需要解压的压缩文件</strong>（dir.tar形式）</p><p><strong>tar –xvzf</strong> <strong>需解压的压缩文件</strong>（压缩文件为dir.tar.gz形式）</p><p>压缩命令：</p><p><strong>tar –cvf</strong> <strong>压缩文件名（压缩为dir.tar形式） 该目录的压缩路径</strong></p><p><strong>tar –cvzf</strong> <strong>压缩文件名（压缩为dir.tar.gz形式） 该目录的压缩路径</strong></p><p><strong>-x</strong> 从备份文件中还原文件</p><p><strong>-v</strong> 显示指令执行过程</p><p><strong>-f</strong> 指定备份文件</p><p><strong>-c</strong> 建立新的备份文件</p><p><strong>-z</strong> 通过gzip指令处理备份文件</p><h4 id="3临时获取超级用户权限"><a class="markdownIt-Anchor" href="#3临时获取超级用户权限"></a> 3.临时获取超级用户权限</h4><p><strong>sudo</strong> 需要做的事情</p><h4 id="4vi"><a class="markdownIt-Anchor" href="#4vi"></a> <a href="http://4.vi">4.vi</a> 编辑器的使用</h4><p>（1）安装软件包</p><p>离线安装</p><p>*<em>sudo  dpkg  -i  <em>.deb</em></em> <strong>软件包名</strong> （你的软件包必须在你的当前目录下）</p><p>在线安装</p><p><strong>sudo  apt-get  install</strong>  <strong>软件包名</strong></p><p>（2）配置</p><p>运行配置脚本进行配置</p><p>（3）使用</p><p><strong>vi</strong> <strong>文件名</strong>   （通过vi编辑器打开文件）</p><p>命令模式-编辑模式（按下i键进入）-命令模式（按下esc键回到）-低行模式（shift+；进入）</p><p>低行模式命令（1）<strong>w</strong>  保存</p><p>（2）<strong>q</strong>  退出</p><p>（3）<strong>wq</strong>或<strong>x</strong>  保存并退出</p><h4 id="5gcc编译器"><a class="markdownIt-Anchor" href="#5gcc编译器"></a> 5.gcc编译器</h4><p>（1）<strong>gcc  file.c</strong>                   （默认生成的可执行文件a.out）</p><p>（2）<strong>gcc  file.c  -o  可执行文件名</strong>  （指定生成的制作的文件名字）</p><p>运行一个可执行文件：<strong>./可执行文件名</strong>（该处没有空格）</p><p>练习：1+2+3+……+100</p><h2 id="二-linux下常用服务开启"><a class="markdownIt-Anchor" href="#二-linux下常用服务开启"></a> 二 Linux下常用服务开启</h2><h4 id="1tftp服务实现文件传输开发板-pc机"><a class="markdownIt-Anchor" href="#1tftp服务实现文件传输开发板-pc机"></a> 1.tftp服务：实现文件传输（开发板-pc机）</h4><p>（1）安装软件包</p><p>（2）配置服务（修改配置文件）</p><p><strong>sudo  vi  /etc/default/tftpd-hpa</strong></p><p>(3)重新启动服务</p><p><strong>sudo  /etc/init.d/tftpd-hpa  restart</strong></p><p>(4)本机测试服务是否通过</p><p>（输入指令：netstat –a | grep tftp 如果显示udp 0 0 <em>：tftp</em>：*则说明tftp安装了且已启动）</p><p>&lt;1&gt;在制定的服务工作目录路径下</p><p>（/home/linux/workdir/fs4412/tftpboot/）下存放一个文件（hello.c）</p><p>&lt;2&gt;切换到你的用户主目录下，输入：</p><p>tftp  127.0.0.1</p><p>tftp&gt;get 下载的文件  （你所下载的文件必须已经存放在服务器工作目录路径下）</p><p>tftp&gt;q</p><p>注意：如果下载成功，下载下来的文件存放在你当前目录</p><p>&lt;1&gt;启动tftp服务：sudo /etc/init.d/tftpd-hpa start</p><p>&lt;2&gt;确认tftp服务已开启</p><p>cmd：netstat –a | grep tftp</p><p>如果显示udp 0 0 <em>：tftp</em>：*则说明tftp安装了且已启动</p><h4 id="2nfs网络文件系统network-file-system"><a class="markdownIt-Anchor" href="#2nfs网络文件系统network-file-system"></a> 2.NFS网络文件系统（Network File System）</h4><p>通过对网络文件系统的支持，用户可以在本地系统上像操作本地分区一样对远程主机的共享分区（目录）进行操作（类似windows共享目录）。</p><p>如果你要是安装了图形界面的话，按Alt+F7或者在命令行输入init 5 或者startx任何一个肯定是可以的。要是不可以的话，估计是你在安装的时候没有安装桌面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-linux常用命令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-linux常用命令&quot;&gt;&lt;/a&gt; 一 linux常用命令&lt;/h2&gt;
&lt;h3 id=&quot;linux常用命令分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor</summary>
      
    
    
    
    <category term="文档区" scheme="http://uerlink.github.io/categories/%E6%96%87%E6%A1%A3%E5%8C%BA/"/>
    
    
    <category term="Linux" scheme="http://uerlink.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>初学者</title>
    <link href="http://uerlink.github.io/2025/04/23/%E2%80%8B%E8%BF%81%E6%80%9D%E5%9B%9E%E8%99%91/2025-04-23_%E5%88%9D%E5%AD%A6%E8%80%85/"/>
    <id>http://uerlink.github.io/2025/04/23/%E2%80%8B%E8%BF%81%E6%80%9D%E5%9B%9E%E8%99%91/2025-04-23_%E5%88%9D%E5%AD%A6%E8%80%85/</id>
    <published>2025-04-22T16:00:00.000Z</published>
    <updated>2025-04-23T14:41:33.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个初学者面对新领域的思考"><a class="markdownIt-Anchor" href="#一个初学者面对新领域的思考"></a> 一个初学者面对新领域的思考</h1><h3 id="学不完的行业知识"><a class="markdownIt-Anchor" href="#学不完的行业知识"></a> 学不完的行业知识</h3><p>在社会上人们都有一个共识，想要高工资、好待遇，大多数人都会想到“学习”两个字，最常听到的一句话“去学一门手艺/技术”，但问题是怎么去学，怎么入门？他们不会告诉你。现在人类发展太快了，科技与技术水平的发展，在这一两百年间成指数级上升，要学的知识太多太多。<br />正常情况应该选一个行业去专入学习，把庞大的体系细分化，（我觉得这也是大学专业越来越多了的原因），但问题来了每当我们踏足一片新领域时，我们面对铺天盖地的专有名称和行业基本知识会感到无比彷徨。部分人可以会尝试利用网络去搜索词条，但往往会被其发展数十年的知识背景给吓倒，学一个知识点时其知识又牵扯出多个知识点，如同树干变成枝叶一般，需要学习的内容越来越多。</p><p>教员说过“<strong>战略上藐视 战术上重视</strong>”</p><p>“初学者不必气馁，任何一个领域或行业都有其专业的知识，<strong>对于这些基本知识，随着学习的不断深入，有些知识自然而然地就懂了，不必刻意去专门学习</strong>，其中最有效的学习方式就是多听多问，多与行业的人交流沟通。”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一个初学者面对新领域的思考&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一个初学者面对新领域的思考&quot;&gt;&lt;/a&gt; 一个初学者面对新领域的思考&lt;/h1&gt;
&lt;h3 id=&quot;学不完的行业知识&quot;&gt;&lt;a class=&quot;markdownIt-Anc</summary>
      
    
    
    
    <category term="迁思回虑" scheme="http://uerlink.github.io/categories/%E8%BF%81%E6%80%9D%E5%9B%9E%E8%99%91/"/>
    
    
    <category term="学习" scheme="http://uerlink.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>怎样使用类和对象</title>
    <link href="http://uerlink.github.io/2025/04/23/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023_%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://uerlink.github.io/2025/04/23/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023_%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</id>
    <published>2025-04-22T16:00:00.000Z</published>
    <updated>2025-04-23T15:19:03.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的初始化"><a class="markdownIt-Anchor" href="#对象的初始化"></a> 对象的初始化</h2><p>不能在类声明中对数据成员进行初始化（因为类不是一个实体，是一个抽象类型，不占用存储空间）</p><pre class="highlight"><code class="hljs c++">Class Time&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> x,y,z;<br>&#125;;<br>Time t1=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>&#125;<br></code></pre><h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3><p>成员函数包含构造函数，构造函数的<strong>函数名必须和类名一样</strong>不然就变成成员函数了<br />如果用户没有在类中定义构造函数，那么系统会自动生成一个<strong>空的</strong>的构造函数<br /><em>注意</em>：</p><ol><li>构造函数没有返回值</li><li>构造函数不能调用</li><li>构造函数是在对象<strong>创建之前系统自动调用的</strong></li></ol><h4 id="构造函数实现初始化"><a class="markdownIt-Anchor" href="#构造函数实现初始化"></a> 构造函数实现初始化</h4><p>使用构造函数给成员变量的赋值初始化数据。</p><pre class="highlight"><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Time</span>()&#123;<br>hour=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> hour;<br>&#125;;<br></code></pre><h4 id="带参数的构造函数实现初始化"><a class="markdownIt-Anchor" href="#带参数的构造函数实现初始化"></a> 带参数的构造函数实现初始化</h4><p>普通形式</p><pre class="highlight"><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Time</span>(<span class="hljs-type">int</span> x)&#123;<br>hour=x;   <span class="hljs-comment">//不再限定值，类外给什么就是什么</span><br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> hour;<br>&#125;;<br></code></pre><p>带成员构造表形式（推荐）</p><pre class="highlight"><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Time</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">hour</span>(x)&#123;<br><br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> hour;<br>&#125;;<br></code></pre><h4 id="构造函数的重载"><a class="markdownIt-Anchor" href="#构造函数的重载"></a> 构造函数的重载</h4><p>构造函数的重载和函数重载类似。可以实现创建对象的时候是否赋值，赋值类型，赋值个数，来分别调用不同构造函数。</p><p><em>注意</em>：可以不用参数而调用的构造函数，一个类中只能有一个</p><p><em>无参构造函数</em>：（默认的构造函数），如果不自己写无参构造函数，那么系统会自己生成一个<strong>空的</strong>无参构造函数。<br />在生成对象的时候，要调用无参的，只能写出 “类名+对象名;”不能写出&quot;类名+对象名()”</p><p><em>有参构造函数</em>：<br />注意：<strong>应在声明构造函数的指定默认值</strong>，而不能只在定义构造函数时指定默认值</p><h3 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h3><p><em>作用</em>：不是删除对象，而是在系统撤销对象占用的内存<strong>之前</strong>完成一些自定义清理</p><p><em>注意</em>：</p><ol><li>一个类可以有多个构造函数，但只能有一个析构函数</li><li>析构函数不能被重载</li><li>和类名同名+“<strong>~</strong>”符号</li><li><em>越先构造的对象，就越后被析构</em></li></ol><pre class="highlight"><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Time</span>(<span class="hljs-type">int</span> x)&#123;<br>hour=x;   <span class="hljs-comment">//不再限定值，类外给什么就是什么</span><br>&#125;<br>~<span class="hljs-built_in">Time</span>()&#123;    <span class="hljs-comment">//析构函数</span><br><br><br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> hour;<br><br><br>&#125;;<br></code></pre><h2 id="对象数组"><a class="markdownIt-Anchor" href="#对象数组"></a> 对象数组</h2><p><strong>结构</strong>：类名 + 对象名[] = {x,y,z}</p><p>如果构造函数有多个参数，如果单独赋值</p><pre class="highlight"><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>:<br>&#123;<br><br><br>&#125;;<br>T s[<span class="hljs-number">3</span>]=&#123;<br><span class="hljs-built_in">box</span>(<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>),<br><span class="hljs-built_in">box</span>(<span class="hljs-number">121</span>,<span class="hljs-number">124</span>,<span class="hljs-number">124</span>),<br><span class="hljs-built_in">box</span>(<span class="hljs-number">123</span>,<span class="hljs-number">513</span>,<span class="hljs-number">12</span>),<br><br>&#125;<br><br></code></pre><h2 id="对象指针"><a class="markdownIt-Anchor" href="#对象指针"></a> 对象指针</h2><h3 id="指向对象的指针"><a class="markdownIt-Anchor" href="#指向对象的指针"></a> 指向对象的指针</h3><p><strong>结构</strong>：类名 星号 对象指针名</p><pre class="highlight"><code class="hljs c++">*<span class="hljs-built_in">pt</span><br>(*pt).hour  <span class="hljs-comment">//和 pt-&gt;hour 一样</span><br><br></code></pre><h3 id="指向对象成员的指针"><a class="markdownIt-Anchor" href="#指向对象成员的指针"></a> 指向对象成员的指针</h3><p><strong>结构</strong>：数据类型名 星号 指针变量名</p><h3 id="this指针"><a class="markdownIt-Anchor" href="#this指针"></a> this指针</h3><p>每个成员函数中都包含一个<strong>特殊的指针</strong>，就是<strong>this指针</strong><br />指向本类对象的指针，它的值是<strong>当前被调用</strong>的成员函数所在对象的起始地址。</p><pre class="highlight"><code class="hljs C++"><span class="hljs-comment">//对象a</span><br><span class="hljs-keyword">this</span>-&gt;width; <span class="hljs-comment">//和 a.width 效果一样</span><br></code></pre><p>this是隐形的</p><pre class="highlight"><code class="hljs c++"><span class="hljs-comment">//类名：Box</span><br><span class="hljs-comment">//编写的时候</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Box::a</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span>(width);<br>&#125;<br><br><span class="hljs-comment">//实际情况</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Box::a</span><span class="hljs-params">(box * <span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span>(<span class="hljs-keyword">this</span>-&gt;width);<br>&#125;<br></code></pre><h2 id="共用数据的保护"><a class="markdownIt-Anchor" href="#共用数据的保护"></a> 共用数据的保护</h2><h3 id="常对象"><a class="markdownIt-Anchor" href="#常对象"></a> 常对象</h3><p><strong>结构</strong>：类名 const 对象名【(实参)】    或者     const 类名 对象名【(实参)】</p><p>定义成常对象后，该对象的数据成员都变成常数据成员了，而且该对象只能调用它的常成员函数</p><p><em>注意</em></p><ol><li>常对象<strong>只能调用常成员函数</strong></li><li>常成员函数可以访问常对象的数据成员</li><li><strong>非</strong>常成员函数，不能引用和修改常对象的数据成员</li></ol><p><img src="https://s2.loli.net/2025/04/23/KCvR1eyI9gucrkd.png" alt="500" / srcset="https://s2.loli.net/2024/03/18/YVbUifPl92JZX5B.gif" data-src="https://s2.loli.net/2025/04/23/KCvR1eyI9gucrkd.png" class="lozad post-image"></p><h3 id="常数据成员"><a class="markdownIt-Anchor" href="#常数据成员"></a> 常数据成员</h3><p><strong>结构</strong>：const 类型 数据成员名</p><p><em>注意</em></p><ol><li>将类的某个数据成员声明为常数据成员后，则每个对象而言，该数据成员都是常数</li></ol><h3 id="常成员函数"><a class="markdownIt-Anchor" href="#常成员函数"></a> 常成员函数</h3><p><strong>结构</strong>：类型 函数名 const</p><p><em>注意</em></p><ol><li>常成员函数在声明和编写的时候都必须写上 const</li><li>常成员函数<strong>不能修改</strong>常对象中的数据成员</li></ol><h4 id="mutalbe"><a class="markdownIt-Anchor" href="#mutalbe"></a> mutalbe</h4><p><strong>结构</strong>：mutable int x;<br />可以使用mutalbe 把常对象中的某个数据成员，定义成可变的数据成员</p><p>定义常成员函数</p><pre class="highlight"><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;   <span class="hljs-comment">//将函数声明成const</span><br></code></pre><h3 id="对象的赋值"><a class="markdownIt-Anchor" href="#对象的赋值"></a> 对象的赋值</h3><p><strong>结构</strong>：对象2=对象1</p><p><em>注意</em></p><ol><li>只能赋值数据成员，不能赋值成员函数</li><li>不能动态分配对象，否则会赋值报错</li></ol><h3 id="对象的复制"><a class="markdownIt-Anchor" href="#对象的复制"></a> 对象的复制</h3><p><strong>结构</strong>：类名 对象2(对象1)<br />也可以写成 类名 对象1=对象2</p><p><em>注意</em></p><ol><li>复制调用的是复制构造函数</li></ol><p><strong>赋值和复制的区别</strong>：<br />赋值是已经存在对象，复制是新建对象</p><h3 id="静态数据成员"><a class="markdownIt-Anchor" href="#静态数据成员"></a> 静态数据成员</h3><p><strong>结构</strong>：static 类型 变量名；</p><p>静态数据成员是各对象所共用的，不属于某个对象，但是对象可以引用该静态数据成员</p><p><em>注意</em></p><ol><li>一般数据成员对象建立时分配空间，对象撤销时释放空间，静态数据成员在程序开始时分配空间，整个程序结束后才释放空间</li><li>静态数据成员可以通过类名访问（普通数据成员不能）：<strong>类名::变量名</strong> 必须用 <strong>::</strong></li></ol><h3 id="静态成员函数"><a class="markdownIt-Anchor" href="#静态成员函数"></a> 静态成员函数</h3><p><strong>结构</strong>：static 类型 函数名();</p><p>静态成员函数是类的一部分，而不是对象的一部分，但是对象也可以调用静态成员函数</p><p><em>注意</em></p><ol><li>静态成员函数只能引用静态数据成员</li></ol><h3 id="友元"><a class="markdownIt-Anchor" href="#友元"></a> 友元</h3><p><strong>结构</strong>：friend 类型 函数名(类名 &amp;);</p><p>friend 是写在类中，声明类外的普通函数为友元函数, 友元函数可以引用该类中的public数据成员</p><pre class="highlight"><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">dis</span><span class="hljs-params">(Time &amp;)</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dis</span><span class="hljs-params">(Time&amp; t)</span></span>;  <span class="hljs-comment">//注意括号中的值</span><br></code></pre><p><em>注意</em></p><ol><li>friend 函数也可以是另一个类中的成员函数（但引用是单项的），注意提前声明</li><li>友元可以访问本类中的私有成员</li><li>不要过多的使用友元</li></ol><h3 id="友元类"><a class="markdownIt-Anchor" href="#友元类"></a> 友元类</h3><p><strong>结构</strong>：friend 类名;<br />把整个类声明为友元</p><h3 id="类模板"><a class="markdownIt-Anchor" href="#类模板"></a> 类模板</h3><p><strong>结构</strong>：template&lt;class 虚拟类型名&gt;<br />要使用模板时，这一行必须写在类声明前面，注意这一行结尾没有 <strong>;</strong></p><p>也可以使用多个虚拟类型名<br />template&lt;class X, class Y ,class Z&gt;</p><p>使用了虚拟类型名的类(类模板)，在创建对象时，<br /><strong>格式</strong>：类模板名 &lt;实际类型名&gt; 对象名</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象的初始化&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#对象的初始化&quot;&gt;&lt;/a&gt; 对象的初始化&lt;/h2&gt;
&lt;p&gt;不能在类声明中对数据成员进行初始化（因为类不是一个实体，是一个抽象类型，不占用存储空间）&lt;/p&gt;
&lt;pre class=</summary>
      
    
    
    
    <category term="文档区" scheme="http://uerlink.github.io/categories/%E6%96%87%E6%A1%A3%E5%8C%BA/"/>
    
    
    <category term="Cplusplus" scheme="http://uerlink.github.io/tags/Cplusplus/"/>
    
    <category term="笔记" scheme="http://uerlink.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>类和对象的特性</title>
    <link href="http://uerlink.github.io/2025/04/23/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023_%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <id>http://uerlink.github.io/2025/04/23/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023_%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7/</id>
    <published>2025-04-22T16:00:00.000Z</published>
    <updated>2025-04-23T15:19:06.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类和对象"><a class="markdownIt-Anchor" href="#类和对象"></a> 类和对象</h1><h2 id="关键词解释"><a class="markdownIt-Anchor" href="#关键词解释"></a> 关键词解释</h2><p><strong>对象</strong>：具有<em>属性</em>（数据）和<em>行为</em>（函数）的, 对象是系统的基本单位</p><p><strong>封装</strong>：封把一个对象的一部分属性和功能对外界进行屏蔽，留下少量接口，装把数据和操作代码装到一个对象中</p><p><strong>抽象</strong>：表示同一类事物的本质</p><blockquote><p>类是对象的抽象，对象则是类的具体实</p></blockquote><p><strong>继承与重用</strong>：存在基类（父类）与派生类（子类）</p><p><strong>多态性</strong>：同一个消息，不同的对象有不同的响应</p><h2 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h2><blockquote><p>面向对象是一种编程思路和建模思想，与编程语言没有直接关系</p></blockquote><h3 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3><p>区分方法：看是否有一种用户自定义的变量类型</p><h4 id="面向对象对比面向过程的好处"><a class="markdownIt-Anchor" href="#面向对象对比面向过程的好处"></a> 面向对象对比面向过程的好处</h4><ol><li>数据与处理程序分开</li><li>数据和处理过程是隐蔽的</li><li>数据结构改变，不会改变其他的处理过程</li></ol><h2 id="类的声明和对象的定义"><a class="markdownIt-Anchor" href="#类的声明和对象的定义"></a> 类的声明和对象的定义</h2><p><strong>类</strong>：同类型的对象抽取<em>共同性</em></p><blockquote><p>类其实是一种自定义数据类型 , 不占存储空间，对象占空间</p></blockquote><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>类</mtext><mo>=</mo><mtext>数据</mtext><mo>+</mo><mtext>成员函数</mtext></mrow><annotation encoding="application/x-tex">类 = 数据 + 成员函数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">类</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">员</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span></span></span></span></span></p><p><strong>实例化</strong>：定义对象的过程，new 一个对象</p><h3 id="访问限定符"><a class="markdownIt-Anchor" href="#访问限定符"></a> 访问限定符</h3><p><em>protected</em>：不能被类外访问，允许被“派生类”的成员函数访问<br /><em>private</em>：<br /><em>public</em>：</p><h2 id="定义类和对象"><a class="markdownIt-Anchor" href="#定义类和对象"></a> 定义类和对象</h2><p>1.先声明，再定义<br />2.在声明的同时定义对象</p><pre class="highlight"><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br>.....<br>&#125;stud1,stud2;<br></code></pre><p>3.不出现类名，直接定义对象（不推荐）</p><h3 id="class和struct的区别"><a class="markdownIt-Anchor" href="#class和struct的区别"></a> class和struct的区别</h3><p><em>class</em>：使用class定义类时，默认private<br /><em>struct</em>：使用struct定义类时，默认public</p><h3 id="定义成员函数"><a class="markdownIt-Anchor" href="#定义成员函数"></a> 定义成员函数</h3><p><em>注意</em>构造函数和成员函数不能化等号</p><h4 id="在类内定义"><a class="markdownIt-Anchor" href="#在类内定义"></a> 在类内定义</h4><h4 id="在类外定义"><a class="markdownIt-Anchor" href="#在类外定义"></a> 在类外定义</h4><p>在类中声明函数（也可以声明最前面加上<em>inline</em>，让函数变成内置函数），然后在函数名前面写上 类名+全局作用域限定符（如果声明的时候加上<em>inline</em>就需要在函数最前面再加上<em>inline</em>）</p><pre class="highlight"><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> num;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::display</span><span class="hljs-params">()</span></span>&#123;<br>cout&lt;&lt;num;<br>&#125;<br></code></pre><h3 id="成员函数的存储方式"><a class="markdownIt-Anchor" href="#成员函数的存储方式"></a> 成员函数的存储方式</h3><p>使用<strong>sizeof(类名或变量类型)</strong> 可以获取该类对象所占用的字节数</p><blockquote><p>填写类名时，输出的字节数等于该类所有变量占的内存</p></blockquote><pre class="highlight"><code class="hljs CPP">cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(类名或变量类型)&lt;&lt;endl;<br></code></pre><h2 id="对象成员的引用"><a class="markdownIt-Anchor" href="#对象成员的引用"></a> 对象成员的引用</h2><h4 id="通过对象名和成员运算符访问"><a class="markdownIt-Anchor" href="#通过对象名和成员运算符访问"></a> 通过对象名和成员运算符访问</h4><h4 id="通过指针访问对中的成员"><a class="markdownIt-Anchor" href="#通过指针访问对中的成员"></a> 通过指针访问对中的成员</h4><p>对象类型指针</p><blockquote><p>类名 *指针名</p></blockquote><p>指针指向符号 ** -&gt;**  ，p-&gt;hour 等效 t.hour</p><pre class="highlight"><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> hour;<br><br>&#125;;<br>Time t,*p;   <span class="hljs-comment">//创建一个对象和对象类型指针</span><br>p = &amp;t;      <span class="hljs-comment">//将对象地址给对象类型指针</span><br>cout&lt;&lt;p-&gt;hour;  <span class="hljs-comment">//也可以使用cout&lt;&lt;p.hour</span><br></code></pre><h4 id="通过对象的引用来访问"><a class="markdownIt-Anchor" href="#通过对象的引用来访问"></a> 通过对象的引用来访问</h4><p>直接引用</p><pre class="highlight"><code class="hljs CPP">Time t1;<br>Time &amp;t2=t1;<br></code></pre><p>在向函数传递时引用</p><pre class="highlight"><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span>&#123;<br><br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Time&amp;)</span> <span class="hljs-comment">//声明函数</span></span><br><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(t1)</span></span>;<br><span class="hljs-built_in">set</span>(t2);<br><span class="hljs-built_in">set</span>(t3);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Time&amp; t)</span></span>&#123;<br><br><br>&#125;<br></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类和对象&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类和对象&quot;&gt;&lt;/a&gt; 类和对象&lt;/h1&gt;
&lt;h2 id=&quot;关键词解释&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关键词解释&quot;&gt;&lt;/a&gt; 关键词解释&lt;</summary>
      
    
    
    
    <category term="文档区" scheme="http://uerlink.github.io/categories/%E6%96%87%E6%A1%A3%E5%8C%BA/"/>
    
    
    <category term="Cplusplus" scheme="http://uerlink.github.io/tags/Cplusplus/"/>
    
    <category term="笔记" scheme="http://uerlink.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件目录操作</title>
    <link href="http://uerlink.github.io/2025/04/23/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023_Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/"/>
    <id>http://uerlink.github.io/2025/04/23/%E6%96%87%E6%A1%A3%E5%8C%BA/2023/2023_Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/</id>
    <published>2025-04-22T16:00:00.000Z</published>
    <updated>2025-04-23T15:13:02.660Z</updated>
    
    <content type="html"><![CDATA[<h3 id="linux的目录结构"><a class="markdownIt-Anchor" href="#linux的目录结构"></a> Linux的目录结构</h3><ul><li><strong>/</strong>（根目录）<ul><li><strong>bin</strong>（binary的缩写，二进制目录，包括系统管理员和普通管理员使用的Linux命令）</li><li><strong>boot</strong>（存放系统核心文件以及启动时必须读取的文件，包括 Linux 内核）</li><li><strong>dev</strong>（device的缩写，存放外部设备代码文件）</li><li><strong>etc</strong>（etcetera的缩写所有系统管理和维护的配置文件，是Linux系统的中心）</li><li><strong>home</strong><ul><li>用户的目录（目录名以用户的账号命名）</li></ul></li><li><strong>root</strong>（超级管理员ROOT的主目录）</li><li><strong>run</strong>（保存从系统安装到当前的关于系统信息的 文件）</li><li><strong>sbin</strong></li><li><strong>tmp</strong>（临时文件）</li><li><strong>usr</strong> （user的缩写，应用程序存放目录）<ul><li><strong>bin</strong></li><li><strong>local</strong></li><li><strong>sbin</strong>（sudo bin超级用户的 linux 命令，类似于/bin）</li><li><strong>tmp</strong></li><li><strong>snap</strong>（软件安装框架的程序文件）</li></ul></li><li><strong>var</strong> （variable的缩写，系统日志，共享文件）<ul><li><strong>tmp</strong>（临时文件）</li></ul></li><li><strong>media</strong>（U盘，光盘挂载目录）</li><li><strong>mnt</strong>（移动硬盘挂载目录）</li></ul></li></ul><h3 id="文件目录操作"><a class="markdownIt-Anchor" href="#文件目录操作"></a> 文件/目录操作</h3><blockquote><p>目录就是一个文件</p></blockquote><h4 id="查看文件目录"><a class="markdownIt-Anchor" href="#查看文件目录"></a> 查看文件/目录</h4><p>命令：<strong>l</strong> 或 <strong>ls</strong> —查看文件列表<br />命令：<strong>la</strong> 或 <strong>l -a</strong> —查看包括隐藏文件<br />命令：<strong>ll</strong> —查看文件列表详细信息<br />命令：<strong>pwd</strong> —显示当前目录路径</p><h4 id="切换目录"><a class="markdownIt-Anchor" href="#切换目录"></a> 切换目录</h4><p>命令：<strong>cd 目录名或完整路径</strong> —跳转路径<br />命令：<strong>cd -</strong> —回到刚刚访问的目录<br />命令：<strong>cd …</strong> —回到上级目录<br />命令：<strong>cd</strong> 或 <strong>cd ~</strong> —回到自己的主目录下</p><h4 id="操作文件"><a class="markdownIt-Anchor" href="#操作文件"></a> 操作文件</h4><p><strong>touch 文件名</strong>  —新建文件<br /><strong>mkdir 目录名</strong>  —新建目录<br /><strong>vim 文件名</strong> —新建文件<br /><strong>rm  文件名</strong>  —删除文件<br /><strong>rm -rf 目录</strong>   —删除非空目录<br /><strong>rmdir 目录名</strong>  —删除空目录<br /><strong>cp 文件名  新文件名</strong>  —复制文件<br /><strong>mv 文件名 新文件名</strong>  —移动文件<br /><strong>cat 文件名</strong> ----显示文件内容<br /><strong>head -n 文件名</strong> —显示多少行的文件内容（不输入-n 默认10）<br /><strong>tail -n 文件名</strong>  —显示后几行的文件内容<br /><strong>wc 文件名</strong> —结果显示 4 个，分别为行数，字数，字节数，文</p><h4 id="创建链接文件"><a class="markdownIt-Anchor" href="#创建链接文件"></a> 创建链接文件</h4><blockquote><p>理解为创建快捷方式</p></blockquote><p><strong>ln -s 原文件 链接文件</strong>  —软链接<br /><strong>ln 原文件 链接文件</strong>   —硬链接<br />例: ln -s ~/happy.txt ~/桌面/happy</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;linux的目录结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux的目录结构&quot;&gt;&lt;/a&gt; Linux的目录结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;/&lt;/strong&gt;（根目录）
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;b</summary>
      
    
    
    
    <category term="文档区" scheme="http://uerlink.github.io/categories/%E6%96%87%E6%A1%A3%E5%8C%BA/"/>
    
    
    <category term="Linux" scheme="http://uerlink.github.io/tags/Linux/"/>
    
    <category term="目录结构" scheme="http://uerlink.github.io/tags/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
